# MORE

https://www.w3.org/Protocols/

https://developer.mozilla.org/

[RedBot](https://redbot.org/), 检查缓存相关的 HTTP 头的工具.

# 《HTTP权威指南》

## 第一章 HTTP概要

### 内容提要

* 这一章主要介绍了什么是http以及http是干嘛的，以及与之有关的相关概念，当然了这些概念都是概览式的介绍一些。所以我将采用问答式的方式描述这一章！


**Q:http是干嘛的？**

A:http是数据传输协议（超文本传输协议），用来沟通客户端和服务器的！


**Q:什么是资源？**

A:记住一句话，网络上的一切内容皆资源，无论是静态文件，还是动态生成的代码等！

**Q:什么是媒体类型？**

A:其实就是一种数据类型标记，用来告诉接收端，接收到的数据是什么类型，让接收端知道怎么才能处理该文件！常见标记方式就是MIME，MIME描述了文件的主要类型以及特定子类型，例如："Content-Type":"text/html"，其中text描述的文件的主要类型是文本，而其特定类型是html文档！


**Q:怎么理解URI以及它的子集？**

A:首先URI从其概念来说是*统一资源标识符*，它的作用就是在网络上唯一确定一个资源，就好比，在中国，身份证能唯一确定一个人一样！知道身份证号，就一定能确定一个人姓甚名谁一样！它有两个子集：URL(统一资源定位符)和URN(统一资源名)，首先不特别声明，我们所说的URI就是指URL，URL是跟资源其在网络上的位置有关！而URN是指资源跟其名字有关，URN是未来的趋势，不过貌似具体实施现在还在商讨中！所以短时间之内URN难以取代URL！


**Q:什么是事务？**

A:说白了事务就是“一次http链接（不包括tcp/ip连接，只包括一次http报文发送与接收）”的整个过程，由请求命令和响应结果组成！中间数据格式是http报文。我们平常打开一个网站，里面包括很多事务！如：请求网页文档、请求某个logo图片及请求某个视频等！

**Q:方法指什么？**

A:方法就是客户端向服务器发起的请求命令！常见方法有：get、post、delete、put、head！

**Q:状态码有什么用？**

A:状态码对程序有用，便于程序进行相关控制！原因短语对人有用！

> | 分类 | 分类描述                                       |
> | :--- | :--------------------------------------------- |
> | 1**  | 信息，服务器收到请求，需要请求者继续执行操作   |
> | 2**  | 成功，操作被成功接收并处理                     |
> | 3**  | 重定向，需要进一步的操作以完成请求             |
> | 4**  | 客户端错误，请求包含语法错误或无法完成请求     |
> | 5**  | 服务器错误，服务器在处理请求的过程中发生了错误 |
>
> https://www.runoob.com/http/http-status-codes.html

**Q:简单介绍一些报文！**

A:首先报文是http协议一种纯文本的数据格式，分为请求报文和响应报文，两种报文都具有类似的结构，分别由三个部分构成：起始行、首部、主体，起始行描述报文干了什么！首部描述报文传输的具体细节！主体描述传输的实际内容！

**Q:什么是TCP/IP？跟HTTP有什么关系？**

A:tcp/ip是全世界的计算机和网络设备常用的层次化分组交换网络协议集！简单的说，http协议是一个应用层协议，位于tcp/ip协议的上一层，tcp/ip协议的主要作用就是过滤掉每个计算机的差异性，隐藏相关弱点，使得对于http协议来说提供的都是“相同的”接口！

**Q:在一次网络请求中，分别经历那些过程？**

A:步骤如下：

>(a)浏览器从url中解析处服务器的主机名；
>(b)浏览器将服务器的主机名转换成服务器的的ip地址；（可能经过去dns服务器查询）
>(c)浏览器将端口号（如果有的话）从url中解析出来；
>(d)浏览器建立一条与web服务器的tcp连接；
>(e)浏览器向服务器发送一条http请求报文；
>(f)服务器向浏览器回送一条http响应报文；
>(g)关闭连接，浏览器显示文档


Q:http协议有哪些版本？

A:

>http/0.9，这个版本有严重设计权限
>http/1.0，广泛使用
>http/1.0+ 非官方的http/1.0的扩展版本
>http/1.1 目前正在使用的版本，修复的相关设计缺陷，增加的相关特性
>http-NG 将来使用与否正在商讨中



**Q:介绍一下web中的一些结构组件？**

A:主要有代理、缓存、网关以及隧道！分别简介如下：

- 代理：代理位于客户端和服务器之间，接收所有客户端的HTTP请求，并把这些请求转发给服务器（可能会对请求进行修改之后转发）。对用户来说，这些应用程序就是一个代理，代表用户访问服务器。代理的主要作用有过滤、屏蔽等！（还有需要注意一点：代理既可以代表服务器对客户端进行响应，又可以代表客户端对服务器进行请求！）


- 缓存：首先说明一下，缓存某种意义上来说也是一种代理服务器。它主要使用代表服务器对客户端进行响应。发送预先缓存好的资源的副本。这样会加快事务响应速度、同时也会减少服务器的负载、减轻带宽等问题！


- 网关：网关是一种特殊的服务器，面对客户端时好像它就是服务器，而对于服务器，他又充当客户端的角色，它的主要作用是协议转换！例如HTTP/FTP网关。


- 隧道：就是一个连接通道，用于在http信道上发送非http协议的资源。


- Agent代理：说白了就是我们平时所说的浏览器，以及web机器人、爬虫等！

## 第二章 URL与资源

#### 内容提要

* 本章讲解了URI（统一标识符）严格来说，这一章是介绍URL(统一资源定位符)的!分别介绍了URL是由那些组件构成、每个组件代表的含义是什么、浏览器是如何解析每个组件的以及从URL的完成性和安全性来说如何进行URL不安全字符进行转义。当然最后还简单介绍了URI的另一个子类URN（统一资源名）。

#### URI的分类

* URI（统一资源标识符）由URL（统一资源定位符）和URN（统一资源名）两个子集构成。URL是从资源的位置来定义一个资源的，比如在“中国三东的一只小狗”和在“中国广东的一只小狗”就分别定义了两只不同的狗。而URN是从资源的名字来定义的，比如小明和小李就分别定义了两个人。目前的网络架构来说，大部分都是URL。URL的缺点就是如果资源的位置发生了改变，那么资源也就找不到了，而URN正是解决这个问题的，因为URN不受位置的限制，它只受名字的管理，因为对于URN来说，一个资源的名字是唯一的，所以无论资源移动到什么地方，都能通过名字定位到资源。从某种意义上来说，URN是URI的未来趋势，但是URN的实现需要一个中间架构来满足这种位置到名字的映射，所以要完成从URL到URN的过度，显然是一个工程量的过程，如果不是URL到了不能用的时候，URN的实现需要很长的时间，幸运的是现在URL架构还是很好的满足网络需求的！

#### URL的语法

* URL的语法描述的是URL由哪些组件构成，以及这些组件是怎么组合成一个URL，中间由什么符号连接，每个组件代表什么等！其格式如下：

```html
<scheme>://<user>:<password>@<host>:<port>/<path>;<params>?<query>#<frag>
```

其中：

>scheme:方法描述了请求资源时用了什么协议，用“:”与url其它部分隔开；
>user:用户名描述了访问是带的用户名；
>password:密码描述了用户名后面可能跟的密码，用“:”跟用户名隔开；
>host:主机描述了网站主机名或ip地址，如果前面有用户名和密码，用@分开；
>post:服务器当前正在监听的端口，http默认为80，https默认为443;
>path:路劲描述了资源在服务器上的位置，用‘/’跟前面部分隔开；
>params:参数描述了请求需要附加的参数，用“;”与其他部分隔开；
>query:查询是用来激活服务器程序去执行某些操作，比如查询数据库等，用“?”与其余部分隔开；用&来连接两个键值对。
>
>![image-20210216160404812](D:\OneDrive_PAO\OneDrive - std.uestc.edu.cn\note\img\image-20210216160404812.png)
>
>frag:片段只在客户端使用，不发送到服务器端；






#### URL快捷方式

* url快捷方式描述了一种程序如何通过相对地址解析处绝对地址的过程以及在浏览器地址栏输入部分url浏览器自动补全主机名的一种机制！

* 相对地址转换为绝对地址：首先会根据一个基础地址来得出协议、主机名、端口等！基础地址可以通过base标签显示定义，也可以由当前所在资源的地址得出！相关接口通过继承的方式附在相对地址上，最后得到绝对地址。

* 浏览器扩展地址主要通过主机名扩展和历史扩展等方式实现自动地址补全！



#### url编码

Q:为什么需要编码？

A:主要从url的**一致性、安全性、以及完整性**来强调需要对url字符进行编码。比如因为一个url连接的两端可能出现的机器种类很多，为了让大家都能够解析出一个相同的url，所以有必要对某些不安全的url字符进行转义。

Q:url字符集由什么编码构成？

A:早前的url是有US-ASCII码编码，但是随着网络在全世界的流行，有很多字符是US-ASCII不能编码的，因为US-ASCII码最多只能编译127个字符。通过转义序列，就可以用US-ASCII字符集的有限子集对任意字符值或数据进行编码了。

Q:编码机制？

A:为了避开安全字符集表示法带来的限制，人们设计了一种编码机制，用来在URL中表示各种不安全的字符。这种编码机制就是通过一种“转义”表示法来表示不安全字符的，这种转义表示法包含一个百分号（%），后面跟着两个表示字符的ASCII码的十六进制数。

Q:那些字符不建议在URL里面使用？

A:在URL中，有几个字符被保留起来，有着特殊的含义。有些字符不在定义的US-ASCII可打印字符集中。还有些字符会与某些因特网网关和协议产生混淆，因此不赞成使用，比如“%”。

## 第三章  HTTP报文

### 内容提要

这一章内容较多，介绍了http报文的诸多相关概念，譬如起始行、首部、主体以及它们代表的含义等！同时还介绍了常见的状态码及其含义，常见的首部字段及其含义。本章内容较丰实，所以概念模糊的部分可以参阅原书相关章节！


#### 报文流

**这是形容http报文的**

* http报文是以一种类似的流的方式来发送数据的，所以报文流讲述了http报文的一些客观状态，相关术语：流入、流出形容事务处理。http报文任何时候是从上游向下游流入的！其中进过的节点既可能是上游，有可能是下游，如果从某个节点流出，那么相对于此节点流入的那个节点，它就是上游，反过来它就是下游！
* 类似于时序图

![image-20210216161443381](D:\OneDrive_PAO\OneDrive - std.uestc.edu.cn\note\img\image-20210216161443381.png)


#### 报文的组成部分

* 首先说明，报文由三个部分组成，**起始行、首部、主体**。==起始行和首部都是ascll文本，而主体则可以是任意类型文件，比如二进制，视频等！==且起始行和首部都已一个crlf作为结束符，并且首部与主体之间应始终存在一个以crlf序列作为结束的空行。当然了为了兼容老版本的http，这里有时并不是那么严格要求非要crlf同时存在！


* 报文的语法

http报文分为请求报文和相应报文，其语法分别如下：

```html
	//请求报文

	<method> <request-URL> <version>
	<headers>

	<entity-body>

```

```html
	//响应报文

	<version> <status> <reason-phrase>
	<headers>

	<entity-body>

```

相关概念分别如下：


	方法是客户端希望执行的动作，如GET、POST等
	请求url是指请求资源的路径
	http版本号，格式为http/<major>.<minor>,分别代表主要版本号和次要版本号，其含义应分开理解
	status code其实说白了就是用一个数字表示当前事务处于什么状态，便于开发者处理
	原因短语，实际意义不大，就是为了方便人看的
	首部就是一个包含零个或多个的键值对，键值对以crlf隔开，而键、值之间以‘:’隔开，期间包含一个可选的空格
	主体任意格式组成的数据块，也是实际发送的内容


* 起始行

分为请求行和响应行，格式前面一个在前面，相关概念不在赘述！

* 首部

说一下首部分类，主要有五类：通用首部、请求首部、响应首部、主体首部、扩展首部。通用首部就是请求报文和响应报文都可以用，用以说明报文的一般属性；请求首部出现在请求报文中，用于客户端告诉服务器是什么情况，比如能接受什么，不能接受什么等；响应报文用于响应报文中，服务器端用来告诉客户端什么情况；主体首部用来描述主体的信息，比如主体的长度是多少等；扩展报文是非官方的报文，但是http也支持发送。

#### 方法

* 安全方法

能在服务器端有操作的就是非安全方法，比如delete、put、post,不在服务器端有操作的就是安全方法，比如get、head，当然了安全方法并非不能在服务器端有操作，这是开发者可以控制的！

* GET方法用于请求服务器端发送某个资源

* HEAD方法跟GET方法类似，区别就是不返回主体

* PUT方法用于向服务器端修改、插入数据

* POST方法用于向服务器端发送数据

* TRACK方法用于向服务器端请求报文在发送的过程中经过了什么修改，主要用于测试

* OPTIONS用于请求服务器告知其支持什么功能

* DELETE用于向服务器删除某个指定的资源

* 扩展方法其实类似于自定义方法

PUT和POST都有更改指定URI的语义.但PUT被定义为idempotent的方法，POST则不是.idempotent的方法:如果一个方法重复执行多次，产生的效果是一样的，那就是idempotent的。也就是说：

- PUT请求：如果两个请求相同，后一个请求会把第一个请求覆盖掉。（所以PUT用来改资源）
- Post请求：后一个请求不会把第一个请求覆盖掉。（所以Post用来增资源）

####　状态码

* 100-199 信息性状态码

* 200-299 成功状态码 （常见200表示请求成功）

* 300-399 重定向状态码 （常见302重定向）

* 400-499 客户端错误状态码 （常见404，请求资源不存在）

* 500-599 服务端错误状态码


#### 常见状态码及其含义整理

```
	状态码				原因短语     				含义
	100					Continue 			说明收到了请求的初始部分，请客户端继续，发送了这个状态码之后，
											服务器在收到请求之后必须进行响应。
	101					Switching Protocols 说明服务器正在根据客户端的指定，将协议切换成Update首部所列的
											协议
	200 				OK					请求没问题，实体的主体部分包含了所请求的资源
	201 				Created				用于创建服务器对象的请求（比如，PUT）。响应的实体主体部分中
											应该包含各种引用了已创建的资源的URL，Location首部包含的则是最具体的引用。
	202 				Accepted			请求已被接受，但服务器还未对其执行任何动作。不能保证服务器会完成这
											个请求；这只是意味着接受请求时，它看起来是有效的。服务器应该在实体的主体部分包含对请求状态的描述，或许还应该有对请求完成时间的估计（或者包含一个指针，指向可以获取此信息的位置）
    203 				Non-Authoritative   实体首部包含的信息不是来自原远端服务器，而是来自于资源的一份副本。 
    					Information 		如果中间节点上有一份资源副本，但无法或者没有对它所发送的与资源有关的
    										元信息进行验证，就会出现这种情况
    204					No 	Content         响应报文中包含若干首部和一个状态行，但没有实体的主体部分。主要用于在
    										浏览器不转为显示新文档的情况下，对其进行更新（比如刷新一个表单页面）
    205					Reset Content 		另一个主要用于浏览器的代码。负责告知浏览器清除当前页面中的所有HTML
    										表单元素
    206					Partial Content 	成功执行了一个部分或Range(范围)请求。稍后我们会看到，客户端可以通过
    										一些特殊的首部来获取部分或某个范围内的文档————这个状态码就说明范围请求成功了。


    注：在对那些包含了重定向状态码的非HEAD请求进行响应时，最好要包含一个实体，并在实体中包含描述信息和指向（多个）重定向URL的链接。如：

    HTTP/1.1 301 OK
    Location: http://www.gentle-grooming.com/
    Content-Length: 56
    Content-Type: text/plain

    Please go to our partner site,
    www.gentle-grooming.com

    300					Multiple Choices 	客户端请求一个实际指向多个资源的URL时会返回这个状态码，比如服务器
    										上有某个HTML文档的英语和法语版本。返回这个代码时会带有一个选项列表；这样用户就可以选择它希望使用的那一项了。有多个版本可用时，客户端需要沟通解决。
    301					Moved Permanently	在请求的URL已被移除时使用。响应的Location首部中应该包含资源现在所处
    										的URL
    302 				Found 				与301状态码类似，但是，客户端应该使用Location首部给出的URL来临时定位
    										资源。将来的请求仍应该使用老的URL
    303 				See Other 			告知客户端应该用另一个URL来获取资源。新的URL位于响应报文的Location
    										首部。其主要母的是允许POST请求的响应将客户端定向到某个资源上去
    304  				Not Modified 		客户端可以通过所包含的请求首部，使其请求变成有条件的。如果客户端发起
    										了一个条件GET请求，而最近资源未被修改的话，就可以用这个状态码来说明
    										资源未被修改。带有这个状态码的响应不应该包含实体的主体部分。
    305 				Use Proxy  			用来说明必须通过一个代理访问资源；代理的位置由Location首部给出。很
    										重要的一点是，客户端是相对某个特定资源来解析这条响应的，不能假定所有请求。甚至所有对持有请求资源的服务器的请求都通过这个代理进行。如果客户端错误地让代理介入了某条请求，可能会引发破坏性的行为，而且会造成安全漏洞。

   	307					Temporary Redireat 与301状态码类似；但客户端应该使用Location首部给出的URL来临时定位资源
   											。将来的请求应该使用老的URL
   	400 				Bad Request 		用于告知客户端发起了一个错误的请求
   	401 				Unauthorized 		返回适当的首部，用于获取客户端访问资源的权限
   	402         		Payment Required    此状态码未使用，保留
   	403                 Forbidden           服务器拒绝请求，可在响应主体中告知原因
   	404  				Not Found           用于告知客户端请求的资源在服务器不存在
   	405 				Method Not Allowd   告知客户端不支持当前方法，并在Allow首部返回支持的方法
   	406 				Not Acceptable     	没有客户端支持的资源类型
  	407 				Proxy Authentication  跟401类似，不过用户代理服务器
   						Requireed 
   	408 				Request Timeout     超时提醒
   	409      			Conflict            请求会造成服务器冲突
   	410  	            Gone   				跟404一样，只不过服务器曾经拥有过该请求资源
   	411 				Length Required    要求客户端发送Content-Length首部
   	412 				Precondition Failed  部分条件验证不通过
   	413   				Request Entity Too Large  客户端发送的主体超过了服务器的希望的长度
   	414 				Request  URL Too Long   客户端请求的时间比服务希望的时间长
   	415 				Unsupported Media Type 	服务器无法理解客户端请求的主体类型
   	416 				Requested Range Not    请求报文所请求的是指定资源的某个范围，而此范围无效或无法满足时
   						Satisfiable   			，使用此状态码
   	417					Expectation Failed 		请求中包含Expect首部，服务器无法满足
   	500					Internal Server Error  服务器错误
   	501 				Not Implemented         请求超出了服务器能处理的范围
   	502 				Bad Gateway 			作为代理或网关使用的服务器从请求响应链的下一条链路上收到了一条
   												伪响应（比如，它无法连接到其父网关）时，使用此状态码
   	503    				Service Unavailable 	用来说明服务器现在无法为请求提供服务，但将来可以。如果服务器
   												知道什么时候资源会变为可用的，可以在响应中包含包含一个
   												Retry-After首部。
   	504 				Gateway Timeout 		与状态码408类似，只是这里的响应来自一个网关或代理，它们在等待另
   												一服务器对其请求进行响应时超时了
    505 				HTTP Version Not        服务器收到的请求使用了它无法或不愿支持的协议版本时，使用此
    					Supported 				状态码。有些服务器应用程序会选择不支持协议的早起版本	


```


#### 常见首部字段含义介绍

* 注：首部分为通用首部、请求首部、响应首部、主体首部、扩展首部！
* ![image-20210216165057657](D:\OneDrive_PAO\OneDrive - std.uestc.edu.cn\note\img\image-20210216165057657.png)

##### 通用首部General

```
   通用的信息性首部

   首部                                         描述
   Connection               允许客户端和服务器指定与请求/响应连接有关的选项
   Date                     提供了日期的时间标志，说明报文是什么时间创建的
   MIME-Version             给出了发送端使用的MIME版本
   Trailer                  如果报文采用了分块传输编码方式，就可以用这个首部列出位于报文拖挂部分的首部集合
   Transfer-Encoding        告知接收端为了保证报文的可靠传输，对报文采用了什么编码方式
   Update                   给出了发送端可能想要“升级”使用的新版本或协议
   Via                      显示了报文经过的中间节点（代理、网关）

   通用缓存首部

   首部                                 描述
   Cache-Control            用于随报文传送缓存指示
   Pragma                   另一种随报文传送指示的方式，但并不专用缓存
```

##### 请求首部Request Header

```
    请求的信息性首部

    首部                                描述

    Client-IP               提供了运行客户端的机器的IP地址
    From                    提供了客户端用户的E-mail地址
    Host                    给出了接收请求的服务器的主机名和端口号
    Referer                 提供了包含当前请求URL的文档的URL
    UA-Color                提供了与客户端显示器的显示颜色有关的信息
    UA-CPU                  给出了客户端CPU的类型或制造商
    UA-Disp                 提供了与客户端显示器（屏幕）能力有关的信息
    UA-OS                   给出了运行在客户端机器上的操作系统名称及版本
    UA-Pixels               提供了客户端显示器的像素信息
    User-Agent              将发起请求的应用程序名称告知服务器

    Accept首部

    首部                                  描述
    Accept                  告诉服务器能够发送那些媒体类型
    Accept-Charset          告诉服务器能够给发送那些字符集
    Accept-Encoding         告诉服务器能够发送那些编码方式
    Accept-Language         告诉服务器能够发送那些语言
    TE                      告诉服务器可以使用那些扩展传输编码

    条件请求首部
    
    首部                                描述
    Expect                  允许客户端列出某请求所要求的服务器行为
    If-Match                如果实体标记与文档当前的实体标记相匹配，就获取这份文档
    If-Modified-Since       除非在某个指定的日期之后资源被修改过，否则就限制这个请求
    If-None-Match           如果提供的实体标记与当前文档的标记不相符，就获取文档
    If-Range                允许对文档的某个范围进行条件请求
    If-Unmodified-Since     除非在某个指定日期之后资源没有被修改过，否则就限制这个请求
    Range                   如果服务器支持范围请求，就请求资源的指定范围

    安全请求首部

    首部                                  描述
    Authorization           包含了客户端提供给服务器，以便对其自身进行认证的数据
    Cookie                  客户端用它向服务器传送一个令牌————它并不是真正的安全首部，但确实隐含了安全功能
    Cookie2                 用来说明请求端支持的cookie版本

    代理请求首部
    
    首部                                  描述
    Max-Forward             在通往源端服务器的路径上，将请求转发给其他代理或网关的最大次数————与TRACE方法一同
                            使用
    Proxy-Authorization     与Authorization首部相同，但这个首部是在与代理进行认证时使用的
    Proxy-Connection        与Connection首部相同，但这个首部是在与代理建立连接时使用的
```

##### 响应首部Response Header

```
    响应的信息性首部

    首部                                        描述
    Age                     （从最初创建开始）响应持续时间
    Public                   服务器为其资源支持的请求方法列表
    Retry-After              如果资源不可用的话，在此日期或时间重试
    Server                   服务器应用程序软件的名称和版本
    Title                    对HTML文档来说，就是HTML文档的源端给出的标题
    Warning                  比原因短语中更详细的警告报文

    协商首部

    首部                                  描述
    Accept-Ranges           对此资源来说，服务器可接受的范围类型
    Vary                    服务器查看的其他首部的列表，可能会使响应发生变化；也就是说，这是一个首部列表，
                            服务器会根据这些首部的内容挑选处最合适的资源版本发送个客户端

    安全响应首部
    
    首部                                    描述
    Proxy-Authenticate      来自代理的对客户端的质询列表
    Set-Cookie              不是真正的安全首部，但隐含有安全功能；可以在客户端设置一个令牌，以便服务器对客户端
                            进行标志
    Set-Cookie2             与Set-Cookie类似
    WWW-Authenticate        来自服务器的对客户端的质询列表
```

##### 实体首部


```
  实体的信息性首部

  首部                                          描述
  Allow                       列出了可以对此实体执行的请求方法
  Location                    告知客户端实体实际上位于何处；用于将接收端丁香到资源的位置上去

  内容首部

  首部                                          描述
  Content-Base                解析主体中的相对URL时使用的基础URL
  Content-Encoding            对主体执行的任意编码方式
  Content-Language            理解主体时最适宜使用的自然语言
  Content-Length              主体的长度或者尺寸
  Content-Location            资源实际所处的位置
  Content-MD5                 主体的MD5校验和
  Content-Range               在整个资源中此实体表示的字节范围
  Content-Type                这个主体的对象类型
  
  实体缓存首部

  首部                                                  描述
  ETag                        与此实体相关的实体标记
  Expires                     实体不再有效，要从原始的源端再次获取此实体的日期和时间
  Last-Modified               这个实体最后一次被修改的日期和时间
```

## 第四章 连接管理

### 内容提要

* 这一章主要讲解了http的下层协议tcp/ip的一些知识点：tcp/ip建立连接需要做的事情，tcp/ip所带来的时延，以及从http的角度出发，提升网络性能的一些方法，涉及到串行连接、并行连接、持久连接、管道连接等概念！以及介绍了如何关闭连接等概念。


#### TCP/IP连接

* TCP/IP是全球计算机及网络设备都在使用的一种常用的分组交换网络分层协议集，位于http下层。其实常谈论的http连接实际上就是tcp连接加上一些使用连接的规则，tcp为http提供了一条可靠的比特传输管道。一旦连接建立起来，在客户端和服务器的计算机之间交换的报文就永远不会丢失、受损或失序。

* 通常http事务发生时会经过几个步骤，下面以访问http://www.xxx.com:80/path/index.html为例说明：

1. 浏览器从地址栏中解析处域名（主机名），也就是拿到www.xxx.com

2. 浏览器根据得到的主机名查询出ip地址，比如算出ip为202.43.78.3，（中间可能经过查找host文件或去查询dns服务器）

3. 浏览器解析出端口（http默认为80，https默认为443）

4. 浏览器发起一条到202.43.78.3端口为80的链接，（重建需要经过几次确定相关参数的来回“握手”）

5. 浏览器发起请求报文

6. 服务器返回响应报文

7. 浏览器关闭连接（其实浏览器和服务器都可以在不通知对方的情况关闭连接）


* TCP流是分段的，由IP分组传输，也就是说最终http报文是以ip分组的形式在网络之间传输。一个ip分组包含的数据信息如下：

``` 
	1. ip分组首部（通常为20字节）
	2. tcp段首部 （通常为20字节）
	3. tcp数据块 （0个或多个字节，实际http报文数据就在这里） 
```

用一句话描述这个过程就是，http报文流给到tcp，tcp把报文分成一段一段的，然后tcp把每个tcp段交给ip，ip封装成一个ip分组，最后传输的是ip分组。（当然了这里我们忽略了ip下面的数据链路层和物理层）

**TCP确定一个连接**

* TCP用四个信息来唯一确定一条连接：源ip地址、源端口号、目的ip地址、目的端口号。只要其中有一个不同，那么就不是同一条连接。在任意时刻计算机都可以有几条tcp连接在打开状态。

#### 对TCP性能的考虑

* 首先相对建立tcp连接、发送http请求报文以及响应报文相比，http事务处理的时间相对短很多很多，此时延可不用讨论，除非你的服务器超负载了或正在处理复杂的运算。因此，http事务的时延往往由以下原因组成：

1. 首先客户端解析ip地址或者端口号需要时间，如果当前没有访问过相关资源，那么解析还需要查询dns服务器，此操作，造成的时延较多，可能花费数十秒。

2. 建立tcp链接会有建立时延，通常2s左右，如果当前的http事务较多，那么会很快叠加上去。

3. 传输、处理请求报文需要时间

4. 回传响应报文需要时间

5. 当然还有其他因素，比如硬件、网络负载，以及报文尺寸等！

* **性能聚焦区域**

这里简要说明一下，建立tcp链接这个过程可能存在的时延分析，包括：经典三次“握手”、tcp慢启动拥塞控制机制等！

* 经典三次“握手”说的就是http事务在建立tcp连接是需要做的相关参数确认过程，大概如下：

1. 客户端发送携带“SYN”标记的TCP段说明发起连接请求

2. 服务端返回“SYN”和“ACK”的TCP段说明已接受

3. 最后客户端发送确认信息以确认连接


* tcp慢启动说明了，tcp连接会随着时间的增加进行自我调谐。这个主要目的防止突然的tcp连接增多导致网络瘫痪，所以它会慢慢的调整传输速度，这个机制就叫做TCP慢启动。



#### HTTP连接的处理

##### 常被误解的connection首部

* connection能承载三种字段值：

```
	HTTP首部字段名，列出了只与此有关的首部；
	任意标签值，用于描述此链接的非标准选项；
	值close，说明操作完成之后需关闭这条持久连接。
```

接收端在收到请求报文之后，对报文进行解析，并查看connection首部中列出的首部列表，并在转发出去之前，删除相关首部，这一行为称为：“对首部的保护”。


##### 串行处理事务时延

* 此种机制描述了http事务一个一个接着发起，不能同时下载更多的资源，使得界面上用户看不到东西，体验不够好。串行连接没有很好的利用tcp/ip连接的慢启动机制！

* 优化方法主要有：

- 并行连接
  - 通过多条TCP连接发起并发的HTTP连接
- 持久连接
  - 重用TCP连接，以消除连接及关闭时延
- 管道化连接
  - 通过共享的TCP连接发起并发的HTTP请求

##### 并行连接

* 浏览同时发起过个http事务，因为是并行的，所以时延也并行的，这样总时延较小，页面呈现更快，体验较好。但也不是总是这样，因为如果在网络速度很慢的时候，多个连接会去竞争本来不多的带宽，那么就谈不上加快速度了。还有就是并行连接也是需要付出代价的，比如增加系统内训消耗、服务器负载，比如有一个100客户端同时对服务发起100tcp并行连接的话，那么服务器就得负责10000个处理请求，很快的你的服务器就会爆掉。当然了，并行连接确实能带来视觉上的速度提升，因为相比于串行连接慢慢地显示数据而并行一下子能全部显示完信息，视觉上并行连接会给人速度更快的感觉！

##### 持久连接

* 持久连接描述的是：如果对同ip、同端口的发起多个http事务连接，那么可以在前一个事务处理完成之后不要关闭tcp连接，以此来减小建立tcp、tcp慢启动所带来的时延。相关概念不再赘述！


##### 管道化连接

HTTP/1.1允许在持久连接上可选地使用请求管道。这是在keep-alive连接上的进一步性能优化。在响应到达之前，可以将多条请求放入队列。当第一条请求通过网络流向地球另一端的服务器时，第二条和第三条请求也可以开始发送了。在高时延网络条件下，这样做可以降低网络的环回时间，提高性能。

* 管道连接的限制

- - 如果不是持久连接就不要使用管道连接

- - 接收端必须按收到请求报文的顺序返回响应报文，因为HTTP报文中没有序列号标签。所以必须靠按序发送响应报文来达到“数据对应”

- - 发送端应该做好数据没有发送完连接就关闭的准备并开始重新发送数据。

- - HTTP客户端不应该用管道化的方式发送会产生副作用的请求（比如POST）。

##### 关闭连接的奥秘

 略

## 第五章 web服务器

### 内容提要

* 本章简单介绍了web服务器原理、实现以及实现处理http事务的一些细节！

#### web服务器

* 定义：实现提供资源或应答的提供者都可以谓之为服务器！

* 从不同形式划分，服务器有以下几种：

  1. 标准计算机上安装的通用服务器，如apache

  2. 购买的服务器

  3. 嵌入式服务器

#### web服务器应该做些什么

1. 接受建立连接请求

2. 接受请求

3. 处理请求

4. 访问报文中指定的资源

5. 构建响应

6. 发送响应

7. 记录事务处理过程


#### 第一步————接受客户端连接

* 客户端收到一条连接之后，那么它将会把新连接添加到现存web服务器连接列表中，用于监视当前连接上的数据传输情况。期间服务器还应该做到通过一定的设备机制阻止未认证或已知恶意黑名客户端的连接，相关设别技术有：客户端主机名设别、通过ident设别客户端用户等！


#### 第二步————接收请求报文

* 主要经过几个步骤来解析报文：

1. 解析请求行，得知方法、url、协议版本，以及crlf符

2. 解析得到以crlf结尾的首部

3. 得到以crlf结尾，标志首部结束的空行（如果有的话）

4. 解析得到主体，（如果有的话）

* web服务可能还会把请求报文用一种自己能快速处理的内部数据结构来存储请求报文！

* 不同的服务器配置预示它能同时处理的事务情况：

1. 单线程web服务器：只能处理一个请求，待当前请求处理完成之后才能处理下一个请求！优点：简单已于实现，适用于低负荷服务器。缺点：不能及时处理其他请求，容易引发延迟过长而导致性能问题。

2. 多线程及多进程web服务器：能同时处理多个请求！优点：响应及时。缺点：构建复杂，容易快速引起内存消耗过大而死机！最好应该对能同时处理的连接数量进行限制！

3. 复用i/o的web服务器：复用i/o

4. 复用i/o和多线程的web服务器：2和3的结合


#### 第三步————处理请求

* 这点留在本书其余章节大篇幅介绍！

#### 第四步————对资源的映射及访问

* 这里介绍了请求资源的一种路径映射关系，说白了就是找到客户端请求资源在服务器的上的目录路径！相关概念有：docroot(文档根目录)、不允许访问根目录的上一级目录。


* 虚拟托管的docroot:在一个服务器上挂了几个web站点，那么这样当请求的资源路径相同时，服务器应该从请求报文首部的host、uri字段找出真正的资源目录，这些目录都是可以配置的！

* 注：这里对用户配置文件根目录和虚拟目录做一下示例说明，以apache为例：

```
  配置文件根目录
  在配置文件httpd.conf中添加一个DocumentRoot行就可以为Apache Web服务器设置文档的根目录了，如：

  	DocumentRoot /user/local/httpd/files


  配置虚拟目录
  对大多数Web服务器来说，配置虚拟托管的文档根目录是很简单的。对常见的Apache Web服务器来说，需要为每个虚拟Web
  站点配置一个VirtualHosts块，而且每个虚拟服务器都要包含DocumentRoot，如：

  <VirtualHost www.joes-hardware.com>
  	ServerName www.joes-hardware.com
  	DocumentRoot /docs/joe
  	TransferLog /logs/joe.access_log
  	ErrorLog /logs/joe.error_log
  </VirtualHost>

  <VirtualHost www.marys-antiques.com>
  	ServerName www.marys-antiques.com
  	DocumentRoot /docs/mary
  	TransferLog /logs/mary.access_log
  	ErrorLog /logs/mary.error_log
  </VirtualHost>

     ... 

```

#### 第五步————构建响应

* 构建响应报文：1、正确设置响应主体的长度（content-length）；2、设置报文的mime类型（content-type）,主要通过与一直mime类型文件匹配得到当前的文件的mime类型，还可以通过文件扩展名，以及硬规定特定目录下的文件拥有某个mime类型；3、控制重定向！

* 服务器端如何得出文件的MIME类型：

```
	Web服务器要负责确定响应主体的MIME类型。有很多配置服务器的方法可以将MIME类型与资源关联起来。

	1、MIME类型（mime.types）
	   Web服务器可以用文件的扩展名来说明MIME类型。Web服务器会为每个资源扫描一个包含了所有扩展名的MIME类型的文件，以确定其MIME类型。这种基于扩展名的类型相关是最常见的！

	2、魔法分类（Magic typing）
	   Apache Web服务器可以扫描每个资源的内容，并将其与一个已知模式表（被称为魔法文件）进行匹配，以决定每个文
	   件的MIME类型。这样做可能比较慢，但很方便，尤其是文件没有标准扩展名的时候。

	3、显示分类（Explicit typing）
	   可以对Web服务器进行配置，使其不考虑文件的扩展名或内容，强制特定文件或目录内容拥有某个MIME类型

	4、类型协商
	   有些Web服务器经过配置，可以以多种文档格式来存储资源。在这种情况下，可以配置Web服务器，使其可以通过与用户的协商来是决定使用哪种格式（及相关的MIME类型）“最好”。

```


##### 重定向

* 有时服务器需要返回重定向报文来构建响应，重定向响应由返回码3XX说明。Location响应首部包含了内容的新地址或优选地址的URL。重定向可用于下列情况。

 - - 永久删除的资源，状态码为301

 - - 临时删除的资源，状态码为303或307

 - - URL增强，状态码为303或307

 - - 负载均衡，主要是减少服务器的压力，让请求跑到一个负载不大的服务器上去，状态码为303或307

 - - 服务器关联，去保存有用户本地信息的服务器上获取用户信息，状态码为303或307

 - - 规范目录名称，客户端请求的URI是一个不带尾部斜线的目录名时，大多数Web服务器都会将客户端重定向到一个加了斜线的URI上，这样相对链接就可以正常工作了！


#### 第六步————发送响应

* 略

#### 第七步————记录事务日志

* 在web服务器日志文件中添加一个条目，以描述当前事务处理情况！



## 第六章 代理

### 内容提要

* 本章主要介绍了http代理方面的概念，包括代理的配置、分类、作用等！

#### web的中间实体

* web上的代理服务器是代表客户端对事务请求处理的中间人！分为私有代理（只代理一个客户端）和公共代理（代理多个客户端）。

* 代理和网关的对比：代理的两端使用相同的协议，而网关的两端使用不同的协议，网关负责协议转换！

#### 为什么使用代理

* 主要使用代理作以下功能使用：

1、儿童过滤器：如服务器响应的成人内容进行过滤

2、文档访问控制：验证客户端访问某个的文件需要的证书

3、安全防火墙：提供一个防火墙保护客户端或服务器

4、web缓存（缓存资源的副本）：对客户端响应资源的副本，节省带宽、减少网络拥堵

5、反向代理（原始服务的替代物，能访问其他服务器，作服务器加速器使用）：反向代理伪装成原始服务器，不过与服务器不同的是反向代理还可以向其他服务器发送请求，以便实现按需定位所请求的内容！

6、内容路由器：比如网络中实现为了一些付费用户提供更好、更快的网络速度，让请求发往缓存服务器，而没有付费的用户请求则发往更远或原始服务器！

7、转码器（比如改变图片格式，以便更轻巧利于传输）

8、匿名者：保护客户端隐私


#### 代理去往何处

* 按部署代理的位置代理可以分为一下几种：

1、出口代理：部署在本地网络端，用于保护本地网络或者限制公司带宽

2、访问（入口）代理：用于实现提供缓存响应

3、反向代理：部署在服务器端本地网络上，用于实现更精确的请求和提供性能

4、网络交换代理：部署在网络上，用于检测流浪等

* 代理层次结构描述的代理的部署层级结构，比如一级代理，二级代理等，这是一种静态层级结构，有父代理和子代理的概念，离原始服务器进的的代理是离服务器远的代理的父代理！但是代理层级不应该静态的，而应该可以是动态的，以保证代理可以根据实际网络负载情况而下发报文到不同的代理！从而产生的动态层级代理概念有**负载均衡**、**地理位置附近的路由**等！

* http请求报文是怎么进入代理的，描述的怎么把http请求报文流量导入代理！主要有一下几种方式：

1、*修改客户端*：比如现在的客户端都支持收手动和自动配置代理！

2、*修改网络*：网络通过一些技术在客户端不知情的情况揽入流量进入代理！

3、*修改dns命名空间*：把主机名映射为代理的ip地址，比如修改系统的dns映射文件，让代理伪装成原始服务器，从而把web请求导入代理！

4、*修改服务器*：让服务器返回一个重定向有关的代码，把http请求报文导入到代理！


#### 客户端代理设置

* 主要介绍客户端配置代理的几种常见方式，如下：

- - 手工配置 : 显示地设置要使用的代理

- - 预先配置浏览器 : 浏览器厂商或发行商会在将浏览器发送给其客户之前预先对浏览器（或所有其他的Web客户端）的代理设置进行手工配置

- - 代理的自动配置（Proxy Auto-Configuration,PAC）：一个代理配置的js文件，客户端在请求之前会取回这个js文件，从而判断如何决定使用代理

- - WPAD的代理发现 : 略

#### 与代理有关的一些棘手问题

1、发送给服务其的url可以是相对路径，而发送给代理的是包含方法、主机名等完整路径！

2、与虚拟主机目录同样存在的问题，可以通过在请求报文的host首部发送确定的主机信息！

3、拦截代理会受到部分url！

4、代理既可以处理代理请求，也可以处理服务器请求！

5、转发过程中对URI的修改

6、URI的客户端自动扩展和主机名解析

7、没有代理URI的解析

8、有显示代理的URI的解析

9、有拦截代理的URI的解析


#### 追踪报文


* 现在代理请求逐步流行的情况下，需要一种机制来追踪我们的报文经过了那些节点。此时报文中via字段就是一个描述报文在代理中逐级传输的过程中所经过代理的方式！如下：

```
	GET /index.html HTTP/1.0
	Accept: text/html
	Host: www.joes-hardware.com
	Via: 1.1 proxy-62.irenes-isp.net,1.0 cache.joes-hardware.com

```

via字符告诉我们报文流经了两个代理。这个字符串说明第一个代理名为proxy-62.irenes-isp.net,它实现了HTTP/1.1协议，第二个代理被称为cache.joes-hardware.com,实现了HTTP/1.0。

* Server响应首部字段对原始服务器使用的软件进行了描述，如下有几个例子：
  * Server: Apache/1.3.14 (Unix) PHP/4.0.4
  * Server: Netscape-Knterprise/4.1
  * Server: Microsoft-IIS/5.0


注：如果响应报文是通过代理转发的，一定要确保代理没有修改Server首部。Server首部是用于原始服务器的。代理应该添加的是Via首部。

#### 代理认证

略

#### 代理的互操作性

略

## 第七章 缓存

[more-HTTP缓存](./mozilla.org/HTTP缓存.md)

### 内容提要

* 本章主要从缓存的架构、优势、节省带宽流量、提升响应及处理步骤等方面阐述了web缓存！

#### 使用缓存的优点

* 缓存减少了冗余的数据传输，因为毕竟每次http事务请求的东西都是一样的时候，多次发送同样的数据是不必要和冗余的！

* 缓存缓解了网络瓶颈的问题，不需要更多的带宽就能够更快地加载页面！

* 缓存降低了对原始服务器的要求，因为想象一下，从一个性能很差劲的原始服务器和从一个性能和牛逼的缓存服务器请求事务，肯定会弥补服务器的缺点的，同时也会减少服务器过载情况，因为大部分请求都由缓存代劳处理了！

* 缓存降低了距离时延，因为从较远的地方加载页面会更慢一些！

#### 冗余的数据传输

* 每次都从原始服务器拿数据，那么带来的后果就是：多次发送重复的数据浪费流量、耗费昂贵的网络带宽从而降低传输速率、加大服务器的负载。而有了缓存之后这些问题都可以迎刃而解！

#### 带宽瓶颈

* 带宽瓶颈说明的问题：很多网络为本地客户端配置的带宽要比远程服务器配置的带宽要宽，如果在这种状况下客户端去请求远程服务器，那么客户端将会以一种的较低的速度去请求服务端，从而没有发挥出客户端带宽宽的长处！如果在客户端方向配置一个高速缓存服务器，那么就可以很快的得到响应，由此也看出带宽对报文传输速率的影响！


#### 瞬间拥塞

* 瞬间拥塞描述的是这样一种情况：一个爆炸性的新闻和热点事件，如果再没有配置缓存的情况下，那么在短时间之内，服务器将会收到突变的请求增长，负荷会爆炸性增长，肯定会吃不消的！但是有了缓存，可以大大分担服务器的负载数量！


#### 距离时延

* 距离时延说明的一个问题就是传输数据过程这个过程是需要时间的，而且路程越长，那么需要的时间也会越多，即时延越长。所以在距离客户端较近的地方部署缓存服务器，减小了传输路程，那么就减小了传输时延！

#### 命中与未命中的

* *缓存命中与缓存未命中：*一次http事务请求如果是从得到的响应是从缓存得到的原始响应副本，那么这样的过程就称之为缓存命中。反之，如果缓存没有响应的副本，而要去请求原始服务，那么就把这个过程称之为缓存未命中！

* *http再验证:*原始响应内容是在变化的，所以缓存应该在文档“过期时间”之后去验证缓存的副本是不是新鲜的，这个过程就叫做http再验证！如果再验证之后得知缓存副本是新鲜的，那么原始服务器返回304 not modified。此时，称之为*再验证命中*或*缓存慢命中*！如果得知缓存不是新鲜的，那么服务器返回200 ok。此时，称之为*再验证未命中*！如果原始对象已经被删除了，返回404 not found响应。相应地缓存副本要删除。（注：虽然再验证命中需要跟原始服务器沟通一次，但是它与直接请求服务器相比，还是要快一点，因为再验证命中只是返回了一些新的过期时间有关的新首部而已，并没有发送主体对象。）


* *命中率*指由缓存返回副本事务在全部事务中所占的比例，称为缓存命中率。这个数据实际中意义不是很大！而*字节命中率*从资源大小总量的角度说明缓存命中所占的比例。因为他从数据流量的角度出发，所以实际中这个数据的意义挺大的！

* *区分命中和未命中*，简单来说，http没有相应的机制来告知客户端响应是从缓存得到的还是从原始服务器得到的！但我们可以从http响应报文首部中的date字段得知这一情况：如果这个字段的时间比当前时间更早得多，说明这是从缓存得到的，因为date描述的服务器第一次响应的时间，而缓存是不会对这个字段进行修改的！


#### 缓存的拓扑结构

* 缓存分为私有缓存（只为一个客户端服务，比如我们给浏览器配置的代理）和共有缓存（为多个客户端服务，现实中是以代理缓存服务器的形式踹出现）。

* 代理缓存的层级结构：此种结构描述的以父、子层级出现的层次结构，同时离客户端越近的子缓存的命中率较低（较廉价），他们可以把请求上升到父缓存（较昂贵），从而在父缓存那里实现事务处理！

* *代理缓存的网状结构*描述的缓存结构并不是很明显呈现父子关系的结构，而是呈无规则的网状！这种结构的思想就是子缓存可以动态选择上一级缓存，从而实现更灵活的缓存控制！

#### 缓存的处理步骤

* 简单概括，即：

``` bash
	接收————解析————查询————新鲜度检测————创建响应————发送————记入日志
```

* 第一步接收：读取网络连接http请求报文

* 第二部解析：把报文解析为片段，并把首部放入到缓存易操作的数据结构中

* 第三步查询：查找存下来缓存副本

* 第四步新鲜度检测：说白了检查缓存副本是不是还有效的

* 第五步创建响应：缓存服务器用原始服务器的缓存副本实现响应的起点，同时再在此基础上做一些修改，比如协议转换等

* 第六步发送：发送报文

* 第七步日志：事务完成之后，在日志文件插入一个条目，用以记录缓存处理情况，以及记录一些与缓存命中率的数据


#### 保持副本的新鲜

* *文档过期*通过特殊的http首部cache-control和expires,http让原始服务器为每个文档设置一个“过期时间”！如：

``` bash
	Cache-Control: Max-Age=484200
	Expires: Fri, 28 Oct 2016 03:03:47 GMT
```

上面的Max-Age是相对时间，以秒为单位，理解为使用期，expires为绝对时间，为到期时间。

* 服务器在验证，描述的过期的文档并不是就是原始服务器的原始文档不一样了，而是需要向服务器发起新鲜度验证请求。

* 用条件方法进行再验证：涉及到的两个首部为If-Modified-Since和If-None-Match。格式为：

``` bash
	If-Modified-Since: <date>
```

实际上上面那个date为服务器响应报文里面Last-Modified的时间。

* If-None-Match:实体标签再验证！此种机制主要跟If-Modified-Since不同在于：If-Modified-Since是根据修改时间来判断文档新鲜度的，但有些情况这样做是不适用的，因为比如我们只是加了注释什么的，其中实际内容是没有变化的，此时我们也应该认为文档是新鲜的！

* 强弱验证器：描述的是一种对内容的更改“严不严重，影不影响主要含义”的实体标签验证！

#### 缓存控制的能力

* 缓存控制能力描述的是服务器可以通过设置相关首部来控制文档的缓存过期时间的能力！相关首部如：

``` 
	Cache-Control: public　//什么都可以缓存
	Cache-Control: private //表明响应只能被单个用户缓存
	Cache-Control: no-store //不能缓存
	Cache-Control: no-cache //在没有对服务器验证之前不能提供内容
	Cache-Control: must-revalidate //严格遵守新鲜验证规则
	Cache-Control: max-age //设置多长时间的过期时间（相对时间）
	Expires: <date> //设置多长的过期时间（绝对时间）
	（试探性过期）不设置首部，让缓存来决定，这个方式涉及到一种算法，比如缓存服务器通过查看最后修改时间，从而得到该文档的修改频繁度，从而为其设置缓存过期时间
```

上面的优先级从上到下依次降低。


* 客户端的新鲜度限制：Web浏览器都有Refresh（刷新）或Reload(重载)按钮，可以强制对浏览器或代理缓存中可能过期的内容进行刷新。Refresh按钮会发布一个附加了Cache-Control请求首部的GET请求，这个请求会强制进行再验证，或者无条件地从服务器获取文档。Refresh的确切行为取决于特定的浏览器、文档以及拦截缓存的配置。客户端可以用Cache-Control请求首部来强化或放松对过期时间的限制，先关首部介绍如下：

```
	Cache-Control请求指令

	指令 							 					目的
	Cache-Control: max-stale  				缓存可以随意提供过期的文件。如果指定了参数<s>，在这段
	Cache-Control: max-stale = <s> 			时间内，文档就不能过期，这条指令放松了缓存的规则
	Cache-Control: min-fresh=<s>   			至少在未来<s>秒内文档要保持新鲜。这就使缓存规则更加严格了
	Cache-Control: max-age = <s> 			缓存无法返回缓存时间长于<s>秒的文档。这条指令会使得缓存规则更加
											严格，除非同时还发送了max-stale指令，在这种情况下，使用期可能会
											超过其过期时间
	Cache-Control: no-cache 				除非资源进行了再验证，否则这个客户端不会接受已缓存的
	Pragma: no-cache 						资源
	Cache-Control: no-store 				缓存应该尽快从存储器中删除文档的所有痕迹，因为其中可能会包含敏感信息
	Cache-Control: only-if-cached 			只有当缓存中有副本存在时，客户端才会获取一份副本
```

#### 设置缓存控制

* 控制Apache的HTTP首部：默认没有开启，需要用到相关模块。如：

- - mod_headers:加载之后就能对相关首部进行配置了，如：

```
	<Files *.html>
		Header set Cache-control no-cache
	</Files>
```

- - mod_expires:mod_expires模块提供的程序逻辑可以自动生成带有正确过期日期的Expires首部

- - mod_cern_meta:略

* 此外，客户端通过HTTP-EQUIV控制HTML缓存，但是值对html文件有用，这种方法并不是很好！

#### 详细算法

* 描述的与响应报文有关一些过期时间或使用时间的计算，详情请参看原书！

#### 缓存广告

* 因为缓存的存在，导致某些靠用户点击次数收费的广告的请求未达到原始服务，从而服务器很难对用户进行了多少次点击进行计数！一种解决方案就是配置缓存，每次访问时都与原始服务器进行再验证。这样，每次访问时都会将命中推向原始服务器，但通常不会传送任何主体数据。当然，这样会降低事务处理的速度。

![image-20210217162603451](D:\OneDrive_PAO\OneDrive - std.uestc.edu.cn\note\img\image-20210217162603451.png)

可以使用redbot网站来查看缓存信息。