more 

> https://juejin.cn/post/6844903662838349838

## 1. 基础知识

### 1.1 3种常见的计算机体系结构划分

OSI分层（7层）：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。
 TCP/IP分层（4层）：网络接口层、网际层、运输层、应用层。
 五层协议（5层）：物理层、数据链路层、网络层、运输层、应用层。

![img](https:////upload-images.jianshu.io/upload_images/53611-6372b2b829bf2820.png?imageMogr2/auto-orient/strip|imageView2/2/w/659/format/webp)

每一层的作用如下：

- 物理层：激活、维持、关闭通信端点之间的机械特性、电气特性、功能特性以及过程特性。该层为上层协议提供了一个传输数据的物理媒体。物理层的任务就是**透明地传送比特流**。
- 数据链路层：数据链路层在不可靠的物理介质上提供可靠的传输。该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。
- 网络层：网络层负责对子网间的数据包进行路由选择。此外，网络层还可以实现拥塞控制、网际互连等功能。
- 传输层：构的最高层，直接**为用户的应用进程提供服务**。
- 运输层的任务是**负责向两个主机中进程之间的通信提供服务**。由于一个主机可同时运行多个进程，因此运输层具有复用和分用的功能。复用是指多个应用层进程可同时使用运输层的服务，分用是指运输层把收到的信息分别交付给应用层中的相应进程。
- 应用层：为操作系统或网络应用程序提供访问网络服务的接口。

### 1.2 常见的网络协议

网络层

- IP协议：网际协议
- ICMP协议：Internet控制报文协议
- ARP协议:地址解析协议
- RARP协议：逆地址解析协议

传输层

- UDP协议：用户数据报协议
- TCP协议：传输控制协议

应用层

- FTP：文件传送协议
- Telenet：远程登录协议
- DNS：域名解析协议
- POP3：邮局协议
- HTTP协议
- SMTP：简单邮件传送协议
- SNMP：简单网络管理协议
- TFTP：简单文件传送协议

## 2. 网际协议IP

IP协议的特点

- **不可靠**：并不保证IP数据报能成功地到达目的地。如果发生某种错误，如某个路由器暂时用完了缓冲区，IP有一个简单的错误处理算法：丢弃该数据报，然后发送ICMP消息报给信源端。任何可靠性必须由上层提供（如TCP）。
- **无连接**：IP并不维护任何关于后续数据报的状态消息，每个连接都是独立的。这也说明，IP数据报可以不按发送顺序接收。

### 2.1 IP首部

普通的IP首部长20个字节（不包含选项字段），包含协议版本号、首部长度、总长度、唯一标识、TTL、首部检验和、源IP地址和目的IP地址。



![img](https:////upload-images.jianshu.io/upload_images/53611-aaa5ffa98abeb59d.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/539/format/webp)

- 通过首部长度和总长度字段就可以知道IP数据报中数据内容的起始位置和长度。
- TTL生存时间字段设置了数据报可以经过的最多路由器数。初始值由源主机设置，一旦经过一个处理它的路由器，其值就减一；当该字段的值为0时，数据报就被丢弃。
- 首部检验和字段是根据IP首部计算的检验和码（ICMP、UDP、TCP检验和同时覆盖了首部和数据部分）。
- 如果长度超过了MTU，则要进行分片，根据IP头部的格式，有一个16位的标识，分片的时候会把这个标识复制到所有的分片中去，也就是说同一个IP的分片，他们的标识是一样的；然后3bit标志中有一位是表示是否最后一片，除了最后一片为0，其它片这个标识位都为1；修改IP的长度为分片中实际数据的长度；片偏移量是该片偏移原始数据的位置。 接收端根据 标识，是否为最后一片，各个片的长度，偏移量就可以把分片的包重新组装起来。

### 2.2 IP地址

IP地址一般有网络号和主机号组成（D类和E类无此分法）。网络号标志主机（或路由器）所连接到的网络，主机号则标志该网络下的主机或路由器。

由于一个路由器至少应当连接到两个网络（这样它才能将IP数据报从一个网络转发到另一个网络），因此一个路由器至少应当有两个不同的IP地址。路由器只根据目的站的IP地址的网络号进行路由选择。

![img](https:////upload-images.jianshu.io/upload_images/53611-7532225bfcde2721.png?imageMogr2/auto-orient/strip|imageView2/2/w/532/format/webp)

上图中的A类、B类、C类地址都是单播地址（一对一通信），是最常用的。网络号字段的最前面有1-4位的类别位。其中有两个特殊的IP地址，**主机号全为0的IP地址代表网络地址，主机号全为1的IP地址为广播地址。当向某个网络的广播地址发送消息时，该网络内的所有主机都能收到该广播消息。**

A类地址：以0开头，第一个字节范围：0~127；
 B类地址：以10开头，第一个字节范围：128~191；
 C类地址：以110开头，第一个字节范围：192~223；
 D类地址：以1110开头，第一个字节范围为224~239；

3个特殊的IP地址

- **255.255.255.255**
   该IP地址指的是受限的广播地址。受限广播地址与一般广播地址（直接广播地址）的区别在于，受限广播地址之只能用于本地网络，路由器不会转发以受限广播地址为目的地址的分组；一般广播地址既可在本地广播，也可跨网段广播。例如：主机192.168.1.1/30上的直接广播数据包后，另外一个网段192.168.1.5/30也能收到该数据报；若发送受限广播数据报，则不能收到。
- **0.0.0.0**
   常用于寻找自己的IP地址，例如在我们的RARP，BOOTP和DHCP协议中，若某个未知IP地址的无盘机想要知道自己的IP地址，它就以255.255.255.255为目的地址，向本地范围（具体而言是被各个路由器屏蔽的范围内）的服务器发送IP请求分组。
- **127.0.0.1**
   127.0.0.0/8被用作回环地址，回环地址表示本机的地址，常用于对本机的测试，用的最多的是127.0.0.1。

### 2.3 划分子网

划分子网的方法是从主机号借用若干个位作为子网号subnet-id，而主机号host-id 也就相应减少了若干个位。于是两级IP地址在本单位内部就变为三级IP地址：网络号、子网号和主机号。

IP地址 ::= {<网络号>, <子网号>, <主机号>}

子网对外部路由器来说隐藏了内部网络组织的细节，在外部看来，不同子网的主机仍属于同一个网络。

凡是从其他网络发送给本单位某个主机的IP数据报，仍然是根据IP数据报的目的网络号net-id，先找到连接在本单位网络上的路由器。然后此路由器在收到 IP 数据报后，再按目的网络号 net-id 和子网号 subnet-id 找到目的子网。最后就将 IP 数据报直接交付目的主机。

如何正确地区分子网号和主机号是一个问题，这可以通过**子网掩码**来确定。将**网络号和子网号全设为1**的IP地址为子网掩码。给定IP地址和子网掩码以后，主机就可以确定IP数据报的目的地是本子网的主机，本网络中其他子网的主机，还是其他网络的主机。

### 2.4 ARP协议与RARP协议

RAP为IP地址到对应硬件地址之间提供动态映射；RARP则相反。RAP高效运行的关键是由于每个主机上都有一个RAP高速缓存，来存放最近Internet地址到硬件地址之间的映射记录。

ARP协议的工作原理

1. 首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。
2. 当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机 MAC地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包，该数据包包括的内容有源主机IP地址、源主机MAC地址、目的主机的IP地址。
3. 当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC 地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。
4. 源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到 ARP响应数据包，表示ARP查询失败。

### 2.5 ICMP（Internet控制报文协议）

ICMP是IP层的一个组成部分，它传递差错报文以及其他需要注意的信息。ICMP报文是在IP数据报内部（IP首部+ICMP报文）被传输的。ICMP报文由类型字段、代码字段、检验和和其他字节组成，前两个字段决定了ICMP报文的类型。

**ICMP地址掩码请求**，用于无盘系统在引导过程中获取自己自己的子网掩码。该ICMP报文的类型字段为17或18，代码字段为0，并返回32位子网掩码。

**ICMP端口不可达差错**，如果收到一份UDP数据报而目的端口与某个正在使用的进程不相符，那么UDP返回一个ICMP不可达报文。ICMP报文必须包括生成差错报文的数据报IP首部，还必须至少包括跟在该IP首部后面的前8个字节。

### 2.6 ping程序

ping程序的目的是为了测试另一台主机是否可达。该程序发送一份ICMP回显请求报文给主机，并等待返回ICMP回显应答。它只利用ICMP回显请求和回显应答报文，而不经过传输层。

ping 127.0.0.1环回地址时，如果不能ping通说明当前机器的TCP/IP协议栈有问题，127本身是一个虚接口，任何时候都是直接上交到内核中处理的。

ping 192.168.1.X 本机的以太网地址，则是测试本机的网络适配器(就是网卡啦)，一般是以太网驱动程序。
 ping这两个地址时你会发现，但使用wireshark抓包时，是没有ICMP的回显请求发出的，这说明这两个ping程序是不会发送到网络中的（只在局域网中）。

ping 同一网段中的网络地址，不通则说明网络线路出现了故障，如果网络中还存在路由器，则应该先ping路由器在本网络的地址，不通则是本机和路由器之间的线路有问题。通了，则再ping路由器所在目标计算机网络所在网段的端口IP地址，不通则说明了路由器出现了故障，通了就再ping目标主机的IP地址。

如果ping [www.baidu.com](https://link.jianshu.com?t=http://www.baidu.com)等网络地址ping不通时，则说明本机的DNS服务器设置错误。

## 3. TCP协议

### 3.1 TCP服务的特点

TCP提供一种**面向连接的、可靠的字节流服务**。面向连接意味着应用程序在使用TCP协议之前，必须先建立TCP连接。在传送数据完毕后，必须释放已经建立的TCP连接。TCP通过以下方式来提供可靠性：

- 应用数据被分割成TCP认为最适合发送的数据块。
- 超时重传。当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到确认，将重发这个报文段。
- 当TCP收到发自TCP连接另一端的数据后，他将发送一个确认。该确认通常将推迟几分之一秒。
- TCP将保持他首部和数据的检验和。
- 由于IP数据报的到达可能会失序，因此TCP报文段的到达也可能失序。如有必要，TCP将对收到的数据进行重新排序，并以正确的顺序交付给应用层。
- 既然IP数据报会发生重复，TCP的接收端必须丢弃重复的数据。
- 流量控制。防止较快主机致使较慢主机的缓冲区溢出。

### 3.2 TCP的首部

![img](https:////upload-images.jianshu.io/upload_images/53611-da2d1badf7d86d0f.png?imageMogr2/auto-orient/strip|imageView2/2/w/631/format/webp)

TCP虽然是面向字节流的，但TCP传送的数据单元却是报文段。一个TCP报文段分为首部和数据两部分，而TCP的全部功能都体现在它首部中各字段的作用。因此，只有弄清TCP首部各字段的作用才能掌握TCP的工作原理。TCP报文首部固定部分各字段的意义如下：

1. **源端口和目的端口**
    各占两字节，分别写入源端口号和目的端口号。TCP的分用也是通过端口实现的。
2. **报文段序号**
    占4字节。在一个TCP连接中传送的字节流中的每一个字节都按顺序编号。整个要传送的字节流的起始序号必须在连接建立时设置，首部中的序号字段值则是指本报文所发送的数据的第一个字节的序号。
3. **确认号**
    期望收到对方下一个报文段的第一个数据字节的序号。若确认号为N，则表明到序号N-1为止的所有数据都已正确收到。
4. **数据偏移**
    指出TCP报文段的数据起始处距离TCP报文段的起始处有多远，实际上指出了TCP报文段的首部长度。
5. **6个控制位**
    确认ACK：TCP规定，在连接建立后所有传送的报文段都必须把ACK置1。
    复位RST：当RST=1时，表明TCP连接中出现严重错误，必须释放连接，然后再重新建立运输连接。
    同步SYN：在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使用SYN=1和ACK=1.
    终止FIN：用来释放一个连接。当FIN=1时，表明此报文段的发送方的数据已发送完毕，并要求释放运输连接。
6. **窗口**
    窗口字段明确指出了现在允许对方发送的数据量，该值经常在动态变化着。例如，设确认号是701，窗口字段是1000。这就表明从701算起，发送此报文段的一方还有接收1000个字节数据的接收缓存空间。

### 3.3 TCP连接的建立与终止过程

![img](https:////upload-images.jianshu.io/upload_images/53611-a0756c435d1df0ef.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/875/format/webp)

**三次握手**
 第一次握手：客户端发送syn包(syn=x)到服务器，并进入SYN_SEND状态，等待服务器确认；
 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态；
 第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。
 握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。

**四次握手**
 与建立连接的“三次握手”类似，断开一个TCP连接则需要“四次握手”。
 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可以接受数据。
 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1。
 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。（与SYN相同，一个FIN占用一个序号）。
 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。

**TCP的半关闭**
 TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力，这就是半关闭。为了使用这一特性，编程接口必须为应用程序提供一中方式来说明“我们已经完成了数据传送，因此发送一个文件结束（FIN）给另一端，但我还想接收另一端的数据，直到它给我发送文件结束FIN”。

**2MSL等待状态**
 TIME_WAIT状态也称为2MSL等待状态。每个具体TCP实现必须选择一个报文段最大生存时间MSL，它是任何报文段被丢弃前在网络内的最长时间（RFC指出其为2min，实现中常用值还有30s和1min）。当TCP执行一个主动关闭，并发回最后一个ACK，该连接必须在TIME_WAIT状态停留的2倍的MSL；这样可让TCP再次发送最后的ACK以防这个ACK丢失（另一方超时并重发最后的FIN）。

### 3.4 使用UDP和TCP的场景

UDP的典型应用：实时性，不需要重传机制，局域网（本身网络稳定性高）

- UDP适合于这样的进程：需要简单的请求-响应通信，而较少考虑流量控制和差错控制。对于需要传送成块数据的进程（如FTP）则不适合使用UDP。
- UDP适合于具有内部流量控制和差错控制机制的进程，如简单文件传输协议TFTP。
- 对多播来说，UDP是一个合适的传输协议。
- UDP常用于交互实时应用，以避免接收报文之间的不一致延时。
- UDP可用于管理进程，如SNMP。

**TCP对应的协议**：

1. FTP：定义了文件传输协议，使用21端口。常说某某计算机开了FTP服务便是启动了文件传输服务。下载文件，上传主页，都要用到FTP服务。
2. Telnet：它是一种用于远程登陆的端口，用户可以以自己的身份远程连接到计算机上，通过这种端口可以提供一种基于DOS模式下的通信服务。如以前的BBS是-纯字符界面的，支持BBS的服务器将23端口打开，对外提供服务。
3. SMTP：定义了简单邮件传送协议，现在很多邮件服务器都用的是这个协议，用于发送邮件。如常见的免费邮件服务中用的就是这个邮件服务端口，所以在电子邮件设置-中常看到有这么SMTP端口设置这个栏，服务器开放的是25号端口。
4. POP3：它是和SMTP对应，POP3用于接收邮件。通常情况下，POP3协议所用的是110端口。也是说，只要你有相应的使用POP3协议的程序（例如Fo-xmail或Outlook），就可以不以Web方式登陆进邮箱界面，直接用邮件程序就可以收到邮件（如是163邮箱就没有必要先进入网易网站，再进入自己的邮-箱来收信）。
5. HTTP协议：是从Web服务器传输超文本到本地浏览器的传送协议。

**UDP对应的协议**：

1. DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。
    **DNS工作原理**：当DNS客户机需要在程序中使用名称时，它会查询DNS服务器来解析该名称。客户机发送的每条查询信息包括三条信息：包括：指定的DNS域名，指定的查询类型，DNS域名的指定类别。该应用一般不直接为用户使用，而是为其他应用服务，如HTTP，SMTP等在其中需要完成主机名到IP地址的转换。
2. SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。
3. TFTP(Trival File Transfer Protocal)，简单文件传输协议，该协议在熟知端口69上使用UDP服务。

## 4. 超文本传送协议HTTP

HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。HTTP协议的主要特点可概括如下：

- 支持客户/服务器模式。
- 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。
- 灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。
- 无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。
- 无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。

### 4.1 浏览网页的过程

浏览网页的过程其实就是浏览器作为一个浏览的“客户端”，向服务器端发送了 一次请求，把服务器端的文件“抓”到本地，再进行解释、展现。

- 使用统一资源定位符URL来标志万维网上的各种文档，并使每一个文档在整个因特网的范围内具有唯一的标识符URL。
- 通过超文本传送协议HTTP来实现万维网上各种连接，使用TCP连接进行可靠的传送。
- 使用超文本标记语言HTML使得网页设计者可以很方便地用链接从本页面的某处链接到任意网页，并在自己主机屏幕上显示。

### 4.2 统一资源定位符URL

URL是用来表示从因特网上得到的资源位置和访问这些资源的方法。URL给资源的位置提供一种抽象的识别方法，并用这种方法给资源定位。只要能够对资源定位，系统就可以对资源进行各种操作，如存取、更新、替换和查找其属性。URL相当于一个文件名在网络范围的扩展。因此，URL是与因特网相连的机器上的任何可访问对象的指针。由于访问不同对象使用的协议不同，URL还能之处读取某个对象时所使用的协议。URL的一般形式为：



```xml
 <协议>://<主机>:<端口>/<路径>
```

协议是指用哪种协议获取该万维网文档，如http，ftp；主机是指该网络文档所在主机的域名；端口和路径有时可以省略。对万维网的网点访问使用HTTP协议，HTTP的默认端口号是80，通常可省略。若在省略文件的路径，则URL就指到因特网上的某个主页。如： [www.baidu.com](https://link.jianshu.com?t=http://www.baidu.com)。

### 4.3 HTTP请求报文

HTTP规定在HTTP客户与HTTP服务器之间的每次交互，都由一个ASCII码串构成的请求和一个“MIME-like”的响应组成，HTTP报文通常都使用TCP连接传送。HTTP有两类报文：请求报文（从客户向服务器发送请求报文）和响应报文（从服务器到客户的回答）。HTTP请求报文和响应报文都是由三部分组成，两种报文格式的区别就是开始行不同。

1. **开始行** 用于区分是请求报文还是响应报文。开始行在两种报文中分别叫**请求行**和**状态行**。
2. **首部行** 用来说明浏览器或报文主题的一些信息。
3. **实体主体** 在请求报文中一般不用该字段，而在响应报文中也可能没有该字段。

请求行只有三个内容，即**方法、请求资源URL和HTTP的版本**。下表给出了请求报文中常用的几种方法。
 GET：请求读取由URL所标志的信息。
 POST：给服务器添加信息（如注释）。
 HEAD：请求获取由Request-URI所标识的资源的响应消息报头。
 PUT：在给定的URL下存储一个文档。
 DELETE：删除给定的URL所标志的资源。

GET方法，在浏览器的地址栏中输入网址的方式访问网页时，浏览器采用GET方法向服务器获取资源。POST方法要求被请求服务器接受附在请求后面的数据，常用于提交表单。POST与GET的区别如下：

- Get是从服务器上获取数据，Post是向服务器传送数据。
- Get是把参数数据队列加到提交表单的Action属性所指向的URL中，值和表单内各个字段一一对应，在URL中可以看到。
- Get传送的数据量小，不能大于2KB；post传送的数据量较大，一般被默认为不受限制。
- 根据HTTP规范，GET用于信息获取，而且应该是安全的和幂等的。
- 所谓安全的意味着该操作用于获取信息而非修改信息。换句话说，GET 请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。
- 幂等的意味着对同一URL的多个请求应该返回同样的结果。



```ruby
GET http://www.bilibili.com/video/douga.html  HTTP/1.1
```

下面是一个请求报文的例子



![img](https:////upload-images.jianshu.io/upload_images/53611-ec8d7daf1793749a.png?imageMogr2/auto-orient/strip|imageView2/2/w/689/format/webp)

请求报文

### HTTP响应报文

在接收和解释请求消息后，服务器返回一个HTTP响应消息。HTTP响应也是由三个部分组成，分别是：状态行、消息报头、响应正文。状态行格式如下：



```undefined
HTTP-Version Status-Code Reason-Phrase CRLF
```

其中，HTTP-Version表示服务器HTTP协议的版本；Status-Code表示服务器发回的响应状态代码；Reason-Phrase表示状态代码的文本描述。

状态代码有三位数字组成，第一个数字定义了响应的类别，且有五种可能取值：
 1xx：指示信息--表示请求已接收，继续处理
 2xx：成功--表示请求已被成功接收、理解、接受
 3xx：重定向--要完成请求必须进行更进一步的操作
 4xx：客户端错误--请求有语法错误或请求无法实现
 5xx：服务器端错误--服务器未能实现合法的请求

常见状态代码、状态描述、说明：



```jsx
200 OK      //客户端请求成功
400 Bad Request  //客户端请求有语法错误，不能被服务器所理解
401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 
403 Forbidden  //服务器收到请求，但是拒绝提供服务
404 Not Found  //请求资源不存在，eg：输入了错误的URL
500 Internal Server Error //服务器发生不可预期的错误
503 Server Unavailable  //服务器当前不能处理客户端的请求，一段时间后可能恢复正常
```

## 5. DNS域名系统

DNS是一中用于TCP/IP应用程序的分布式数据库，它提供域名到IP地址的转换。举例来说，如果你要访问域名math.stackexchange.com，首先要通过DNS查出它的IP地址是151.101.129.69 。

### 5.1 因特网的域名结构

因特网在命名时采用的是层次树状结构的命名方法。任何一个连接在因特网上的主机或路由器，都有一个唯一的层次结构的名字，即域名(domain name)。每一个域名都是有标号(label)序列组成，而各标号之间用点(小数点)隔开。如mail.cctv.com，这是中央电视台用于手法电子邮件的计算机的域名，它由三个标号组成，其中标号com是顶级域名，标号cctv是二级域名，标号mail是三级域名。

### 5.2 域名服务器

如果采用上述的树状结构，每一个节点都采用一个域名服务器，这样会使得域名服务器的数量太多，使域名服务器系统的运行效率降低。所以在DNS中，采用划分区的方法来解决。

一个服务器所负责管辖(或有权限)的范围叫做区(zone)。各单位根据具体情况来划分自己管辖范围的区。但在一个区中的所有节点必须是能够连通的。每一个区设置相应的权限域名服务器，用来保存该区中的所有主机到域名IP地址的映射。总之，DNS服务器的管辖范围不是以“域”为单位，而是以“区”为单位。区是DNS服务器实际管辖的范围。区 <= 域。

因特网上的DNS服务器也是按照层次安排的。每一个域名服务器只对域名体系中的一部分进行管辖。根据域名服务器所起的作用，可以把域名服务器划分为下面四种不同的类型。

- 根域名服务器：最高层次的，也是最重要的域名服务器。所有的根域名服务器都知道所有的顶级域名服务器的域名和IP地址。不管是哪一个本地域名服务器，若要对因特网上任何一个域名进行解析，只要自己无法解析，就首先求助根域名服务器。假定所有的根域名服务器都瘫痪了，那么整个DNS系统就无法工作。很多情况下，根域名服务器并不直接把待查询的域名直接解析出IP地址，而是告诉本地域名服务器下一步应当找哪一个顶级域名服务器进行查询。
- 顶级域名服务器：负责管理在该顶级域名服务器注册的二级域名。
- 权限域名服务器：负责一个“区”的域名服务器。
- 本地域名服务器：本地服务器不属于下图的域名服务器的层次结构，但是它对域名系统非常重要。当一个主机发出DNS查询请求时，这个查询请求报文就发送给本地域名服务器。

### 5.3 域名的解析过程

主机向本地域名服务器的查询一般都是采用递归查询。所谓递归查询就是：如果主机所询问的本地域名服务器不知道被查询的域名的IP地址，那么本地域名服务器就以DNS客户的身份，向其它根域名服务器继续发出查询请求报文(即替主机继续查询)，而不是让主机自己进行下一步查询。因此，递归查询返回的查询结果或者是所要查询的IP地址，或者是报错，表示无法查询到所需的IP地址。

本地域名服务器向根域名服务器的查询的迭代查询。迭代查询的特点：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的IP地址，要么告诉本地服务器：“你下一步应当向哪一个域名服务器进行查询”。然后让本地服务器进行后续的查询。根域名服务器通常是把自己知道的顶级域名服务器的IP地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。顶级域名服务器在收到本地域名服务器的查询请求后，要么给出所要查询的IP地址，要么告诉本地服务器下一步应当向哪一个权限域名服务器进行查询。最后，知道了所要解析的IP地址或报错，然后把这个结果返回给发起查询的主机。

下面举一个例子演示整个查询过程：
 假定域名为m.xyz.com的主机想知道另一个主机y.abc.com的IP地址。例如，主机m.xyz.com打算发送邮件给y.abc.com。这时就必须知道主机y.abc.com的IP地址。下面是上图a的几个查询步骤：

1. 主机m.abc.com先向本地服务器dns.xyz.com进行递归查询。
2. 本地服务器采用迭代查询。它先向一个根域名服务器查询。
3. 根域名服务器告诉本地服务器，下一次应查询的顶级域名服务器dns.com的IP地址。
4. 本地域名服务器向顶级域名服务器dns.com进行查询。
5. 顶级域名服务器dns.com告诉本地域名服务器，下一步应查询的权限服务器dns.abc.com的IP地址。
6. 本地域名服务器向权限域名服务器dns.abc.com进行查询。
7. 权限域名服务器dns.abc.com告诉本地域名服务器，所查询的主机的IP地址。
8. 本地域名服务器最后把查询结果告诉m.xyz.com。

整个查询过程共用到了8个UDP报文。

为了提高DNS查询效率，并减轻服务器的负荷和减少因特网上的DNS查询报文数量，在域名服务器中广泛使用了高速缓存，用来存放最近查询过的域名以及从何处获得域名映射信息的记录。例如，在上面的查询过程中，如果在m.xyz.com的主机上不久前已经有用户查询过y.abc.com的IP地址，那么本地域名服务器就不必向根域名服务器重新查询y.abc.com的IP地址，而是直接把告诉缓存中存放的上次查询结果(即y.abc.com的IP地址)告诉用户。

## 6. 面试题精选

### 例题1：TCP和UDP有什么区别？

TCP是传输控制协议，提供的是面向连接、可靠的字节流服务。当客户和服务器批次交换数据前，必须建立TCP连接之后才能传输数据。TCP提供超时重传、丢弃重复数据、流量控制等功能，保证数据能从一端传到另一端。

UDP是用户数据报协议，是一个简单的面向数据报的运输层协议。UDP不提供可靠性，不保证数据能够到达目的地。由于UDP在传输数据前不用在客户和服务器之间建立连接，且没有超时重传等机制，故而传输速度很快。

### 例题2：TCP的可靠性如何保证？

TCP的可靠性是通过顺序编号和确认（ACK）来实现的。

### 例题3：在浏览器中输入[www.baidu.com](https://link.jianshu.com?t=http://www.baidu.com)后执行的全部过程

1. 客户端浏览器通过DNS解析到[www.baidu.com](https://link.jianshu.com?t=http://www.baidu.com)的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.161.27.48，然后通过TCP进行封装数据包，输入到网络层。
2. 在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。然后使用IP层的IP地址查找目的端。
3. 客户端的网络层不用关系应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，我不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。
4. 客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。

### 例题4：牛客网由于访问客户量的增长,原来的服务器不足以维持请求,经常发生宕机的突发情况,因此为了解决这个问题,CEO决定新增加几台服务器,那么问题是这些接入WEB服务器第一次被访问到时，不同协议的发生顺序是下面中的（ARP -> DNS -> HTTP）。

解析：当你给WEB服务器接上网线的时候，它会自动发送一条ARP信息，使得接入网关能找的到它；网关上会形成一条MAC地址到IP地址的映射记录。如用户在浏览器中输入域名，如本地DNS缓存中没有，必然会进行一次DNS查询，以确定该域名的IP地址。获得DNS对应的IP地址以后，使用HTTP协议访问web服务器（不考虑TCP三次握手建立连接的阶段）。

### 例题5：将一个C类网络划分为3个子网，每个子网最少要容纳55台主机，使用的子网掩码是？（2017乐视实习生）

答：255.255.255.192

### 例题5：IP路由表包括哪几项内容？

IP路由表通常包括三项内容，他们是**子网掩码、目的网络地址、到目的网络路径上“下一个”路由器的地址**。



作者：Mr希灵
链接：https://www.jianshu.com/p/7deb521aba1e
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

# 常见面试题

### 1. 请详细介绍一下 TCP 的三次握手机制，为什么要三次握手？

在讲三次握手之前首先要介绍 TCP 报文中两个重要的字段：一个是序号字段，另一个是确认号字段，这两个字段将在握手阶段以及整个信息传输过程起到重要作用。

1. 第一步：客户端 TCP 向服务端的TCP发送一个不带额外数据的特殊 TCP 报文段，该报文段的 SYN 标志位会被置1，所以把它称为 SYN 报文段。这时客户端会选取一个初始序列号（假设为 client_num），并将此编号放置在序号字段中。该报文段会被封装在一个IP数据报中发送给服务器。
2. 第二步：服务器接收到 SYN 报文段后，会为该 TCP 分配缓存和变量，并发送允许连接的确认报文。在允许连接的报文中，SYN 标志位仍被置为1，确认号字段填的是 client_num + 1的值。最后服务端也会选取一个 server_num 存放到序号字段中，这个报文段称为 SYNACK 报文段。
3. 第三步：在接收到 SYNACK 报文段后，客户端最后也要向服务端发送一个确认报文，这个报文和前两个不一样，SYN 标志位置0，在确认号字段中填上 server_num + 1的值，并且这个报文段可以携带数据。一旦完成这3个步骤，客户端和服务器之间就可以相互发送包含数据的报文了。

如果不是三次握手，二次两次的话，服务器就不知道客户端是否接收到了自己的 SYNACK 报文段，从而无法建立连接；四次握手就显得多余了。

### 2. 讲一讲SYN超时，洪泛攻击，以及解决策略

什么 SYN 是洪泛攻击？ 在 TCP 的三次握手机制的第一步中，客户端会向服务器发送 SYN 报文段。服务器接收到 SYN 报文段后会为该TCP分配缓存和变量，如果攻击分子大量地往服务器发送 SYN 报文段，服务器的连接资源终将被耗尽，导致内存溢出无法继续服务。

解决策略： 当服务器接受到 SYN 报文段时，不直接为该 TCP 分配资源，而只是打开一个半开的套接字。接着会使用 SYN 报文段的源Id，目的Id，端口号以及只有服务器自己知道的一个秘密函数生成一个 cookie，并把 cookie 作为序列号响应给客户端。

如果客户端是正常建立连接，将会返回一个确认字段为 cookie + 1 的报文段。接下来服务器会根据确认报文的源Id，目的Id，端口号以及秘密函数计算出一个结果，如果结果的值 + 1等于确认字段的值，则证明是刚刚请求连接的客户端，这时候才为该 TCP 分配资源

这样一来就不会为恶意攻击的 SYN 报文段分配资源空间，避免了攻击。

### 3. 详细介绍一下TCP的四次挥手机制，为什么要有TIME_WAIT状态，为什么需要四次握手？服务器出现了大量CLOSE_WAIT状态如何解决

当客户端要服务器断开连接时，客户端 TCP 会向服务器发送一个特殊的报文段，该报文段的 FIN 标志位会被置1，接着服务器会向客户端发送一个确认报文段。然后服务器也会客户端发送一个 FIN 标志位为1的终止报文段，随后客户端回送一个确认报文段，服务器立即断开连接。客户端等待一段时间后也断开连接。

其实四次挥手的过程是很容易理解的，由于 TCP 协议是全双工的，也就是说客户端和服务端都可以发起断开连接。两边各发起一次断开连接的申请，加上各自的两次确认，看起来就像执行了四次挥手。

为什么要有 TIME_WAIT 状态？因为客户端最后向服务器发送的确认 ACK 是有可能丢失的，当出现超时，服务端会再次发送 FIN 报文段，如果客户端已经关闭了就收不到了。还有一点是避免新旧连接混杂。

大量 CLOSE_WAIT 表示程序出现了问题，对方的 socket 已经关闭连接，而我方忙于读或写没有及时关闭连接，需要检查代码，特别是释放资源的代码，或者是处理请求的线程配置。

详情可参考以下博客：

https://www.cnblogs.com/sunxucool/p/3449068.html

### 4. 详细讲一下TCP的滑动窗口

![img](https://picgo-w.oss-cn-chengdu.aliyuncs.com/img/1.png)

从上面的图可以看到滑动窗口左边的是已发送并且被确认的分组，滑动窗口右边是还没有轮到的分组。滑动窗口里面也分为两块，一块是已经发送但是未被确认的分组，另一块是窗口内等待发送的分组。随着已发送的分组不断被确认，窗口内等待发送的分组也会不断被发送。整个窗口就会往右移动，让还没轮到的分组进入窗口内。

可以看到滑动窗口起到了一个限流的作用，也就是说当前滑动窗口的大小决定了当前 TCP 发送包的速率，而滑动窗口的大小取决于拥塞控制窗口和流量控制窗口的两者间的最小值。

接着就讲讲什么是流量控制窗口，什么是拥塞控制窗口。

先讲流量控制：

TCP 是全双工的，客户端和服务器均可作为发送方或接收方，我们现在假设一个发送方向接收方发送数据的场景来讲解流量控制。首先我们的接收方有一块接收缓存，当数据来到时会先把数据放到缓存中，上层应用等缓存中有数据时就会到缓存中取数据。假如发送方没有限制地不断地向接收方发送数据，接收方的应用程序又没有及时把接收缓存中的数据读走，就会出现缓存溢出，数据丢失的现象，为了解决这个问题，我们引入流量控制窗口。

假设应用程序最后读走的数据序号是 lastByteRead，接收缓存中接收到的最后一个数据序号是 lastByteRcv，接收缓存的大小为 RcvSize，那么必须要满足 lastByteRcv - lastByteRead <= RcvSize 才能保证接收缓存不会溢出，所以我们定义流量窗口为接收缓存剩余的空间，也就是Rcv = RcvSize - (lastByteRcv - lastByteRead)。只要接收方在响应 ACK 的时候把这个窗口的值带给发送方，发送方就能知道接收方的接收缓存还有多大的空间，进而设置滑动窗口的大小。

接着讲解拥塞控制：

拥塞控制是指发送方先设置一个小的窗口值作为发送速率，当成功发包并接收到ACK时，便以指数速率增大发送窗口的大小，直到遇到丢包（超时/三个冗余ACK），才停止并调整窗口的大小。这么做能最大限度地利用带宽，又不至于让网络环境变得太过拥挤。

最终滑动窗口的值将设置为流量控制窗口和拥塞控制窗口中的较小值。

### 5. 讲一下HTTP与HTTPS的区别

HTTP和HTTPS的主要区别在于HTTP协议传递的是明文数据，而HTTPS传递的是加密过的数据，也就是说HTTPS更具有安全性。也正由HTTPS需要保证安全性，所以它的性能要比HTTP差一点。

单说安全性肯定是不够的，我打算扩展讲一下HTTPS是怎么解决安全性问题的，通过这些HTTP没有机制，反映出HTTPS与HTTP的区别。下面尝试把HTTPS加密的过程推导出来。推导过程不涉及复杂的实现细节：

#### 如何安全地进行数据传输？

假设现在A和B要进行安全的通信，那么究竟怎样才算是安全的通信？很自然地会想到：A和B之间传递数据，这些数据只有A和B才看得懂，中间人就算截取了信息但也看不懂，这才算得上安全。

#### 安全通信的处理手段：

为了能让A和B才能看懂，就必须要对数据进行加密，而且首先想到的就是对称加密。对称加密的意思是A和B各持有一个相同的密钥，它们传递信息时会用密钥给信息加密，在消息到达端给消息解密，完成安全通信。

在对称加密中又会涉及到加密算法的选择问题。现实世界中，通常是多个客户端面向一个服务器的情况，不可能让每个客户端和服务器之间都采用相同的加密算法，如果是这样那和没加密差不多。所以注定每个客户端和服务器之间都会采用不同的加密方式。

#### 如何让每个客户端与服务器之间都采用不同的加密方式？

要想对不同的机器使用不同的加密方式，最直接想到的就是使用随机数。也就说客户端和服务器之间每次都基于一个随机数产生加密算法。（具体实现时为了保证随机，用到还不止一个随机数）

这个产生加密算法的过程称之为协商，现在问题是协商的过程是透明的，也就是说中间人可以截获协商的过程，从而知道我们的加密方式。为了解决这个问题，我们需要对协商的过程进行加密。

#### 如何对协商的过程进行加密？

之所以能来到这一步，是因为我们一开始就选择使用了对称加密，也就说一开始的对称加密导致了现在的问题，所以这时我们不能再使用对称加密了，否则会陷入死循环。

在密码学领域，还有一种加密过程叫非对称加密，它的逻辑是这样的：通信双方一方持有私钥，一方持有公钥，经过私钥加密的信息，都能通过公钥进行解密。但是经过公钥加密的数据，只有私钥可以解密。

按照非对称加密的规则，我们让服务器持有私钥，让客户端持有公钥。这样就能保证客户端给服务器发送消息的时候是安全的（相反，服务器给客户端发送消息就是不安全的），我们可以把协商时重要的逻辑安排在客户端给服务器发送信息的过程中，从而保证了协商过程的安全性。

#### 客户端如何获得公钥？

现在用非对称加密算法解决了协商的安全问题，但是非对称加密的前提是客户端需要获得公钥，这又是一个问题了，客户端与服务器打交道之前是互不知道双方身份的，怎么才能让客户端获得公钥呢？

也就只有两种办法：

1. 客户端向服务器要公钥
2. 客户端向一个远程的公共服务器获取公钥

方法2显然是不行的，尚且不说多了一个访问节点，如何找到公共服务器的地址也是一个待解决的问题，所以还是使用方法1。

但是方法1存在一个问题：如果中间人把服务器发送给客户端的公钥调包了怎么办？也就是说客户端无法知道发送公钥的是否是正真的服务器。

#### 引入第三方机构解决问题

客户端无法辨识服务端和中间人的问题称为“身份验证”问题，也就是说我们需要为服务器向客户端发送公钥的过程进行加密。

这下完了，之前我们因遇到对称加密的瓶颈选择了非对称加密，现在使用非对称加密也遇到了瓶颈。显然这两种加密方式都是不可用的了，否则会再次陷入死循环。

接下来我们只好通过第三方机构的介入，解决这个问题。首先我们自己保存有第三方权威机构的公钥，然后第三方机构使用私钥对服务器将要发送给客户端的公钥进行加密，客户端接收到这个经加密的公钥后（数字证书），就能通过自己保存的第三方机构公钥进行解密。

> 到这里为止，我们解释了HTTPS中使用到的对称加密，非对称加密，CA，数字证书的概念，但是还差一个叫数字签名的概念没有解释。

在现实生活中，CA不单止会给我们正常公司发放证书，还会给中间人的坏公司发放证书，如果中间人把发放的证书调包了怎么办？这时我们仍能用CA的私钥进行解密，但是证书已经被调包了。

那么客户端怎样验证证书的真伪呢？答案是证书本身会告诉客户端如何辨认真伪。比方说证书上面有一个证书编号，还有一个如何计算证书编号的方法，客户端可以根据计算证书编号的方法计算出自己要获得的证书的编号，然后把这个编号和证书上的编号进行比对，如果一样证明没有被调包。

这里的证书编号指的就是数字签名，证书指的就是数字证书。

总结一下HTTPS：HTTPS想要保证客户端与服务器之间的通信安全，就得使用对称加密算法进行加密。协商对称加密算法的过程通过非对称加密算法来保证。在非对称加密算法中，客户端获得公钥的过程需要第三方机构（CA）通过颁发数字证书保证安全性。

总得来说通过这一系列机制协商出了一个对称加密算法后，客户端与服务器之间就能通过该算法进行安全的通信了。

### 6. 讲一讲TCP和UDP各有什么特点，两者有什么区别

1. TCP 是面向连接的，使用 TCP 连接需要经过三次握手，断开连接需要经过四次挥手。相比于 TCP，UDP 则是面向无连接的，它像一个随时可以进行通信的协议，只要接收方创建了 Socket，设置了监听端口，就能接收到到达的 UDP 包，并且能随时建立 Socket 进行发包。
2. TCP 可以对数据的发送速率作控制，它具有流量控制和拥塞控制机制，通过控制滑动窗口的大小控制数据的发送速率。而 UDP 理论上是可以无限地向网络中发数据包的，它的发送速率取决它的应用程序设置。
3. TCP 保证可靠的数据传输，它根据速率控制，重传控制，还有数据校验保证提供可靠的数据传输服务。而 UDP 只是保证尽力而为地传输数据，并不保证数据的可靠性。
4. TCP 的报文段头部占20各字节，比 UDP 的报文段头部多12个字节。消耗的资源更多。由于建立连接有握手的机制，TCP 的使用效率会比 UDP 要低一些。

### 7. 在地址栏键入URL后，网络世界发生了什么？

个人觉得这个问题还可以扩展一下，试想一下在键入 URL 之前，也就是刚开完机的时候，需要联网，然后才能上网。这个阶段包括了获取本机 IP 地址，获取 DNS 服务器 IP 地址，获得网关路由器 IP 和 MAC 地址等操作，把这些一起答上去会不会好一些？以下是回答：

#### 获取本机IP地址，DNS服务器地址，网关路由器地址

首先我们需要准备一个 DHCP 报文，封装在一个 UDP 报文段中，里面包括本机端口号68和目的端口号67，然后到网络层封装成数据包里面包括了本机的初始IP0.0.0.0，和广播地址255.255.255.255。接着到链路层封装成链路层帧。里面包括广播地址和本机网卡的MAC地址。最后发送到本地局域网中

这个数据包最终会被局域网中的 DHCP 服务器发现（有可能有多个 DHCP 服务器），DHCP 服务器会把可用的 IP 地址返回给我们的主机。然后操作系统选择一个 IP 地址并发送给 DHCP 服务器，最后 DHCP 服务器会返回一个包含本机 IP，DNS 服务器 IP，网关路由器 IP 的报文。

接下来我们需要通过网关路由器的 IP 地址去获得网关路由器的 MAC 地址，这样我们才可以把获取网站 IP 的 DNS 请求报文由网关发送给 DNS 服务器。这时候我们需要准备一个 ARP 请求报文，请求获取网关路由器的 MAC 地址，这个报文同样是以广播的方式发送到局域网中，网关路由器接受到请求报文就会把自己的 MAC 地址返回给本机。

#### 获取域名的IP地址

接下来一切都准备好了，可以开始讲键入URL之后的事情了：

首先我们要访问 DNS 服务器获得网站对应的 IP 地址，这时我们需要把 DNS 报文封装到一个 UDP 报文中，进而封装到网络层的数据包中，填上源 IP，目的 DNS 服务器 IP 地址。接着封装链路层，填上网卡 MAC 地址和网关路由器 MAC 地址。接下来这个 DNS 请求报文就会经网关路由器发送给 DNS 服务器。

我们假设 DNS 服务器缓存有该网站的 IP 地址，（如果没有缓存会进一步向更高级的DNS服务器索要IP地址）。接着 DNS 服务器会返回该域名的 IP 地址。

#### 三次握手建立TCP连接

拿到了该网站的IP地址后就可以与该网站的服务器建立 TCP 连接了。建立 TCP 连接需要经过三次握手，过程如下：（更详细的过程在开头）

1. 本机的TCP首先生成一个不带任何数据，SYN标志位为1，序号字段假设为client_num的TCP报文，经过下层一系列网络栈后发送给目的ip服务器。
2. 该服务器接受到TCP请求报文后，会回应一个同意连接的TCP报文，这个报文的SYN标志位也会被置1，序号字段假设为server_num，ACK响应字段为client_num + 1。
3. 接受到同意连接的报文后，我方主机会进行响应，这次的TCP报文SYN位会被置0，序号字段为client_num + 1，ACK响应字段为server + 1。并且这次的响应报文是可以携带数据的。

#### 建立连接后进行数据交互

在三次握手建立连接后，本机就可以向服务器发送 HTTP 请求了，服务器接受到了请求会做出响应的响应，把请求的数据发送给本机浏览器，最终浏览器把服务器响应的数据渲染显示出来，我们就看到了五彩缤纷的网页。

### 8. HTTP的常见状态码有哪些，代表什么含义？

首先状态码的开头不同代表不同的类型：
1xx：代表指示信息，表示请求已接收，继续处理
2xx：代表成功，表示请求已被成功接收，理解，接受
3xx：重定向，表示完成请求必须进行进一步的操作
4xx：客户端错误，请求有语法错误或请求无法实现
5xx：服务器端错误，服务器未能实现合法的请求

常见状态码：
200 OK：正常返回信息
400 Bad Request：客户端请求有语法错误，不能被服务器所理解
403 Forbidden：服务器收到请求，但是拒绝提供服务
404 Not Found：请求资源不存在，输入了错误的URL
500 Internal Server Error：服务器发生不可预期错误
503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常

### 9. GET请求和POST请求的区别

1. 从 HTTP 报文层面来看，GET 请求将信息放在 URL，POST 将请求信息放在请求体中。这一点使得 GET 请求携带的数据量有限，因为 URL 本身是有长度限制的，而 POST 请求的数据存放在报文体中，因此对大小没有限制。而且从形式上看，GET 请求把数据放 URL 上感觉不太安全，而 POST 请求把数据放在请求体里似乎安全一些。实际上想要获取 POST 请求中的内容还是很容易的，因此两者在安全性上其实没有太大差异，想要实现安全的信息传输还是得靠 HTTPS
2. 从数据库层面来看，GET 符合幂等性和安全性，而 POST 请求不符合。这个其实和 GET/POST 请求的作用有关。按照 HTTP 的约定，GET 请求用于查看信息，不会改变服务器上的信息；而 POST 请求用来改变服务器上的信息。正因为 GET 请求只查看信息，不改变信息，对数据库的一次或多次操作获得的结果是一致的，认为它符合幂等性。安全性是指对数据库操作没有改变数据库中的数据。
3. 从其他层面来看，GET 请求能够被缓存，GET 请求能够保存在浏览器的浏览记录里，GET 请求的 URL 能够保存为浏览器书签。这些都是 POST 请求所不具备的。缓存是 GET 请求被广泛应用的根本，他能够被缓存也是因为它的幂等性和安全性，除了返回结果没有其他多余的动作，因此绝大部分的 GET 请求都被 CDN 缓存起来了，大大减少了 Web 服务器的负担。

### 10. 什么是Cookie，Cookie的使用过程是怎么样的？

由于 http 协议是无状态协议，如果客户通过浏览器访问 web 应用时没有一个保存用户访问状态的机制，那么将不能持续跟踪应用的操作。比如当用户往购物车中添加了商品，web 应用必须在用户浏览别的商品的时候仍保存购物车的状态，以便用户继续往购物车中添加商品。

cookie 是浏览器的一种缓存机制，它可用于维持客户端与服务器端之间的会话。由于下面一题会讲到session，所以这里要强调cookie会将会话保存在客户端（session则是把会话保存在服务端）

这里以最常见的登陆案例讲解cookie的使用过程：

1. 首先用户在客户端浏览器向服务器发起登陆请求
2. 登陆成功后，服务端会把登陆的用户信息设置 cookie 中，返回给客户端浏览器
3. 客户端浏览器接收到 cookie 请求后，会把 cookie 保存到本地（可能是内存，也可能是磁盘，看具体使用情况而定）
4. 以后再次访问该 web 应用时，客户端浏览器就会把本地的 cookie 带上，这样服务端就能根据 cookie 获得用户信息了

### 11. 什么是session，有哪些实现session的机制？

session 是一种维持客户端与服务器端会话的机制。但是与 cookie 把会话信息保存在客户端本地不一样，session 把会话保留在浏览器端。

我们同样以登陆案例为例子讲解 session 的使用过程：

1. 首先用户在客户端浏览器发起登陆请求
2. 登陆成功后，服务端会把用户信息保存在服务端，并返回一个唯一的 session 标识给客户端浏览器。
3. 客户端浏览器会把这个唯一的 session 标识保存在起来
4. 以后再次访问 web 应用时，客户端浏览器会把这个唯一的 session 标识带上，这样服务端就能根据这个唯一标识找到用户信息。

看到这里可能会引起疑问：把唯一的 session 标识返回给客户端浏览器，然后保存起来，以后访问时带上，这难道不是 cookie 吗？

没错，session 只是一种会话机制，在许多 web 应用中，session 机制就是通过 cookie 来实现的。也就是说它只是使用了 cookie 的功能，并不是使用 cookie 完成会话保存。与 cookie 在保存客户端保存会话的机制相反，session 通过 cookie 的功能把会话信息保存到了服务端。

进一步地说，session 是一种维持服务端与客户端之间会话的机制，它可以有不同的实现。以现在比较流行的小程序为例，阐述一个 session 的实现方案：

1. 首先用户登陆后，需要把用户登陆信息保存在服务端，这里我们可以采用 redis。比如说给用户生成一个 userToken，然后以 userId 作为键，以 userToken 作为值保存到 redis 中，并在返回时把 userToken 带回给小程序端。
2. 小程序端接收到 userToken 后把它缓存起来，以后每当访问后端服务时就把 userToken 带上。
3. 在后续的服务中服务端只要拿着小程序端带来的 userToken 和 redis 中的 userToken 进行比对，就能确定用户的登陆状态了。

### 12. session和cookie有什么区别

经过上面两道题的阐述，这道题就很清晰了

1. cookie 是浏览器提供的一种缓存机制，它可以用于维持客户端与服务端之间的会话
2. session 指的是维持客户端与服务端会话的一种机制，它可以通过 cookie 实现，也可以通过别的手段实现。
3. 如果用 cookie 实现会话，那么会话会保存在客户端浏览器中
4. 而 session 机制提供的会话是保存在服务端的。

------

参考：
《计算机网络：自顶向下方法》
https://www.cnblogs.com/zhangshitong/p/6478721.html
https://www.cnblogs.com/jiangxinyang/p/8453827.html