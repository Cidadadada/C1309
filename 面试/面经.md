面经推荐：

https://www.nowcoder.com/discuss/472041
https://www.nowcoder.com/discuss/452732
https://www.nowcoder.com/discuss/494464
https://www.nowcoder.com/discuss/472793
https://www.nowcoder.com/discuss/551521
https://www.nowcoder.com/discuss/514092
https://www.nowcoder.com/discuss/427988
https://www.nowcoder.com/discuss/530380
https://www.nowcoder.com/discuss/376697

https://www.nowcoder.com/discuss/505316  



作者：嘟唧＆fish
链接：https://www.nowcoder.com/discuss/584461
来源：牛客网



## 基本情况： 

  本人本科和硕士阶段一直做的是偏[算法]()类的[项目]()，可以说完全没有开发的基础。 

  今年1月份开始刷[剑指offer]()和[算法]()类的[面经]()，3月份开始参加实习生招聘，投得全部都是[算法]()岗，真.海投，但是有反馈的很少，最后只拿了两个offer。 

  经过惨烈的实习招聘以后，秋招我准备不死磕[算法]()，除了[算法]()，还投了测试、[前端]()和[数据分析]()。 

  最后是拿了[电信云]()的[数据分析]()；字节抖音的[前端]()；[华为]()的[算法]()。 

  


##  说明： 

  以下的[面经]()是我自己整理的，主要分为四个板块，分别是【基础知识】、【[算法]()】、【[前端]()】和【测试】，答案都是总结各位大佬分享的经验而得的，可能有总结不到位或者错误的地方，大家斟酌着参考，如有侵权请联系删除！ 

  内容比较多，直接 ctrl+f 应该会快一些哦！ 

  感谢牛客在这一年里给我的帮助，希望我这个分享也能帮助到其他人吧！ 



 

#  **【基础知识】** 

###  **●** **数据库索引和主键的区别** 

 **索引**是用来快速地寻找那些具有特定值的记录的指针 

 **主键**是一种唯一标识记录，是一种唯一性索引 

 区别： 

 1、主键是一种约束，唯一索引是一种索引，两者在本质上是不同的。 

 2、主键创建后一定包含一个唯一性索引，唯一性索引并不一定就是主键。 

 3、唯一性索引列允许空值，而主键列不允许为空值。 

 4、主键可以被其他表引用为外键，而唯一索引不能。 

   5、一个表最多只能创建一个主键，但可以创建多个唯一索引。  

   


   **主键索引**的叶子节点存放的是整行数据  ; 而  **非主键索引**被称为二级索引  ,叶子节点存放的是主键的值。  

   ![img](https://picgo-w.oss-cn-chengdu.aliyuncs.com/img/0CAB14CBE9CC5B5EE0BC1DF9D72BF0A9)  



  

###  **●** **数据库连接** 

 1.INNER JOIN （内连接） 

 2.LEFT JOIN （左连接） 

 3.RIGHT JOIN（右连接） 

 4.OUTER JOIN（外连接、全连接） 

 5.LEFT JOIN EXCLUDING INNER JOIN（左连接不包含内连接） 

 6.RIGHT JOIN EXCLUDING INNER JOIN（右连接不包含内连接） 

   7.OUTER JOIN EXCLUDING INNER JOIN（外连接不包含内连接）  

   ![img](https://picgo-w.oss-cn-chengdu.aliyuncs.com/img/953487AAA0EDF750B2668376D614006C)  



  

  

###  **●** **数据库事务** 

 指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。 

 特性： 

 1、原子性（Atomicity） 

 原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。 

 2、一致性（Consistency） 

 一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。 

 3、隔离性（Isolation） 

 隔离性是当多个用户并发访问数据库时，比如同时操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。 

 4、持久性（Durability） 

   持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。  

   




###  **●** **悲观锁和乐观锁** 

 1、悲观锁，就是对数据的冲突采取一种悲观的态度，也就是说假设数据肯定会冲突，所以在数据开始读取的时候就把数据锁定住。 

   2、乐观锁，认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则返回错误的信息，让用户决定如何去做。  

   




###  **● B****树和B+树** 

 **多路平衡查找树 B-Tree** 

   多路指的一个磁盘块（节点）有  n个子节点，那么当前节点就保存了  n-1个关键字的数据。  

   ![img](https://picgo-w.oss-cn-chengdu.aliyuncs.com/img/EEF799BF57CCD6D657DB45A241ABDED3)  



  

 **加强版多路平衡查找树 B+Tree** 

 1.非叶子节点不存储data，只存储索引key；只有叶子节点才存储data。 

 2.所有叶子节点之间都有一个链指针； 

   3.数据记录都存放在叶子节点中。  

   ![img](https://picgo-w.oss-cn-chengdu.aliyuncs.com/img/88BEB0AFACFD2B7C060988203B065163)  





 

###  **● linux****系统—管道** 

 管道是一种半双工的通信方式，数据只能单项流动，并且只能在具有亲缘关系的进程间流动。有一个读端和一个写端，是单向通信的。 

 | 是管道符，就是把符号左边命令本来要打印到终端上的信息当做右边命令的操作对象 

 


###  **● UDP****和TCP** 

 TCP（传输控制协议）面向连接，UDP（用户数据报协议）无连接 

 TCP可靠，保证安全，UDP尽最大努力交付，不保证安全 

 TCP是点对点的，UDP可以一对一 一对多 多对多 多对一 

 TCP面向字节流，UDP无拥塞控制 

 TCP开销较大，UDP开销小 

 


 **TCP****、UDP的应用场景** 

 UDP使用场景：DNS协议（因为用UDP快），看视频、发语音、QQ聊天、多媒体教室屏幕广播 

 TCP使用场景：HTTP协议，QQ传文件，邮件，登陆 

 


 **TCP****三次握手** 

 初始状态[客户端]()CLOSED，服务器LISTEN 

 1、[客户端]()A向服务器B发送SYN数据包（SYN, x:0）请求连接。此时状态为SYN_SENT，表示[客户端]()已发送SYN报文。 

 2、服务器B收到，发送SYN/ACK数据包（SYN/ACK, y:x+1）回应。此时服务器状态由LISTEN（监听状态）变为SYN_RECV，表示收到SYN报文 

   3、[客户端]()  A收到并发出确认  ACK（  ACK, x+1:y+1），连接成功。双方状态  ESTABLISHED（已建立）  

  

 


 第一次握手：Client什么都不能确认 Server确认了对方发送正常 

 第二次握手： Client确认：自己发送/接收正常，对方发送/接收正常 

 Server确认：自己接收正常 ，对方发送正常 

 第三次握手： Client确认：自己发送/接收正常， 对方发送/接收正常 

   Server确认：自己发送  /接收正常，对方发送  /接收正常  

   ![img](https://picgo-w.oss-cn-chengdu.aliyuncs.com/img/DDBB8E6EA2D24DF207AF5C4A511D249C)  



  

  

 **TCP****四次挥手** 

 初始状态双方ESTABLISHED（已建立） 

 \1. [客户端]()A发送一个FIN，用来关闭客户A到服务器B的数据传送。[客户端]()FIN_WAIT_1。表示主动关闭连接，向对方发送了FIN，进入FIN_WAIT_1，等待对方的确认 

 \2. 服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。[客户端]()FIN_WAIT_2，表示半连接，而服务器可能还有数据要发，这边稍后关闭。服务器CLOSE_WAIT。 

 \3. 服务器B关闭与[客户端]()A的连接，发送一个FIN给[客户端]()A。服务器LAST_ACK，等待对面的ACK报文 

 \4. [客户端]()A发回ACK报文确认，并将确认序号设置为收到序号加1。[客户端]()进入TIME_WAIT，表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL后即可回到CLOSED状态了。 

   ![img](https://picgo-w.oss-cn-chengdu.aliyuncs.com/img/B2DFFDF0602B4E567FB52EF417A32C55)  

   


 **TCP****可靠传输**  

 超时重传 

 数据校验 

 流量控制：滑动窗口 

   拥塞控制：流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。  

   




###  **●** **拥塞控制** 

 1.慢开始 

 TCP发送方首先发送一个数据报，然后等待对方的回应，得到回应后就把这个窗口的大小加倍，然后连续发送两个数据报（指数增长）。为防止拥塞窗口cwnd的增长引起网络拥塞，需要设置慢开始门限ssthresh 

 2.拥塞避免 

 cwnd>ssthresh时,进行拥塞避免算。每个传输轮次，拥塞窗口cwnd只能线性加一。 

 3.快重传 

 发送端如果连续收到3个重复的确认报文端（共4个同样的ACK），就认为是拥塞发生了。发送端知道哪个报文段在传输过程中丢失了，于是重发该报文段，不需要等待超时重传定时器溢出。 

 4.快恢复 

   当发送方连续收到三个重复确认后，就执行“乘法减小”[算法]()，把慢开始门限  ssthresh减半。这是为了预防网络发生拥塞。然后立即重传丢失的报文段，并将  CWND设置为新的  ssthresh，接下去执行拥塞避免。  

   ![img](https://picgo-w.oss-cn-chengdu.aliyuncs.com/img/01048B0A11A5C5704C330F18896A155B)  


 **发送端判断拥塞发生的依据：** 

 1.传输超时（TCP重传定时器溢出）用慢启动和拥塞避免 

   2.接收到重复的确认报文段，用快速重传和快速恢复  

   ![img](https://picgo-w.oss-cn-chengdu.aliyuncs.com/img/8C3BFA63C0640142AA7DCF77428E54A2)  





 

###  **● HTTP****和HTTPS的区别** 

 http是超文本传输协议，信息是明文传输，https（全套接字层超文本传输协议）则是具有安全性的ssl加密传输协议（对称加密：钥匙+钥匙、非对称加密：锁+钥匙），成本较高。http用的端口是80，https用的端口是443。 

 TCP/IP主要解决数据如何在网络中传输。 

   HTTP主要解决如何包装数据。  

   




###  **● HTTP****状态码** 

 1xx 服务器收到请求，需要请求者继续执行操作 

 2xx ok，请求成功 

 3xx 重定向，资源已经重新分配 

 4xx [客户端]()请求错误，403 forbidden请求资源被拒绝，404 not found找不到请求资源 

 5xx 服务器错误，500 服务器故障，503 服务器超载或停机维护 

 


 200，请求成功 

 301，资源（网页等）被永久转移到其它URL 

 302，资源临时移动 

 403，forbidden，服务器理解请求[客户端]()的请求，但是拒绝执行此请求。请求资源**被拒绝**，通常原因是服务器上某些文件或目录设置了权限，[客户端]()权限不够 

 404，not found，用户输入错误的链接，该链接指向的网页不存在。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。 

 500，internal server error 服务器内部错误（比如浏览器代理除了问题，ip，端口不对等）该状态码表明服务器端在执行请求时发生了错误。也有可能是Web应用存在的bug或某些临时的故障。 

 502，Bad Gateway，作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应 

 503，服务器超载或停机维护 

   504，  Gateway Timeout网关超时 服务器作为网关或代理，未及时从上游服务器接收请求。  

   




###  **● Get****和Post的区别** 

 \1. Get是不安全的，因为在传输过程，数据被放在请求的URL中；Post的所有操作对用户来说都是不可见的。 

 \2. Get传送的数据量较小，这主要是因为受URL长度限制；Post传送的数据量较大，一般被默认为不受限制。 

 \3. Get限制Form表单的数据集的值必须为ASCII字符；而Post支持整个ISO10646字符集。 

   \4. Get执行效率却比  Post方法好。  Get是  form提交的默认方法。  

   




###  **●** **网络模型** 

 ![img](https://picgo-w.oss-cn-chengdu.aliyuncs.com/img/4CC865F8F8D422AF5996938AAEB153C7) 

 ![img](https://picgo-w.oss-cn-chengdu.aliyuncs.com/img/61EC8CA98B2212B74D67B9F9ECF00366) 

 1、SMTP：发邮件 

 2、Pop3：收邮件 

 3、SOCKS代理协议服务器常用端口号：1080 

 4、FTP（文件传输）协议代理服务器常用端口号：21 

 5、Telnet（远程登录）协议代理服务器常用端口号：  23  

   


###  **●** **在浏览器中输入一个网址后，发生了什么？** 

 第一步 浏览器查找该域名的 IP 地址 

 第二步 浏览器根据解析得到的IP地址向 web 服务器发送一个 HTTP 请求 

 第三步 服务器收到请求并进行处理 

 第四步 服务器返回一个响应 

 第五步 浏览器对该响应进行解码，渲染显示。 

 第六步 页面显示完成后，浏览器发送异步请求。 

 第七步 整个过程结束之后，浏览器关闭  TCP连接。  

   




###  **●** **进程和线程** 

 进程是资源分配的最小单位，线程是CPU调度的最小单位 

 1、线程在进程下行进，一个进程可以包含多个线程 

 2、不同进程间数据很难共享，同一进程下不同线程间数据很易共享 

 3、进程间不会相互影响，一个线程挂掉将导致整个进程挂掉  

   




###  **●** **进程间的通信方式** 

 **1****、无名管道** 

 1、它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端。 

 2、它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）。 

 3、它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write 等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。 

 **2****、named pipe** 

 1、named pipe可以在无关的进程之间交换数据，与无名管道不同。 

 2、named pipe有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。 

 **3****、消息队列** 

 1、消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。 

 2、消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。 

 3、消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。 

 **4****、信号量** 

 信号量是一个计数器。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。 

 **5****、共享内存** 

 1、指两个或多个进程共享一个给定的存储区。 

 2、因为多个进程可以同时操作，所以需要进行同步。 

   3、信号量  +共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。  

   




###  **● windows****和linux****的区别** 

 Linux是免费且开源的，更安全，可优化。Windows需要收费，需要打补丁和安装防病毒软件。 

 Windows侧重于图形界面，人机交互。Linux侧重于命令行。 

   windows 操作系统内核是  NT，而  linux 是   shell。  

   




###  **●** **安卓和ios的区别** 

 1、两者运行机制不同：IOS采用的是沙盒运行机制，安卓采用的是虚拟机运行机制。 

 2、两者后台制度不同：IOS中任何第三方程序都不能在后台运行；安卓中任何程序都能在后台运行，直到没有内存才会关闭。 

 **沙盒机制：**出于安全考虑，iPhone对于安装在上面的应用程序有所限制，这个限制就是应用程序只能在为该改程序创建的文件系统中读取文件，不可以去其它地方访问，此区域被成为沙盒 

**虚拟机机制：**所有的应用都是运行在一个虚拟的环境中，由底层传输数据到虚拟机中，再由虚拟机传递给用户  UI，任何程序都就可以轻松访问其他程序文件。  

   




###  **● Python** **直接赋值、浅拷贝和深度拷贝** 

 直接赋值：其实就是对象的引用（别名）。 

 浅拷贝(copy)：拷贝父对象，不会拷贝对象的内部的子对象。 

 深拷贝(deepcopy)： copy 模块的 deepcopy 方法，完全拷贝了父对象及其子对象。 

   ![img](https://picgo-w.oss-cn-chengdu.aliyuncs.com/img/99EDDBD3858E6FD90ECA5750D2ABF49F)  

   ![img](https://picgo-w.oss-cn-chengdu.aliyuncs.com/img/0BAB20E213848122803F1EBE346012CE)  


   ![img](https://picgo-w.oss-cn-chengdu.aliyuncs.com/img/56FE2CB48530EC289E7B7DA3695903FE)  



  

#  【[算法]()】 

###  **1****、KNN和Kmeans** 

 ![img](https://picgo-w.oss-cn-chengdu.aliyuncs.com/img/A50C8F623D40FDE034AA12E5B943AB76) 

###  **2****、加快网络的收敛** 

 增大学习率 

###  **3****、过拟合、欠拟合** 

 **过拟合**的原因：训练数据不够多，或者over-training（过度训练），导致在训练集上error减小，而在验证集上error逐渐增大 

 解决方法： 

 1、正则化：在损失函数中加入正则项来惩罚模型的参数，以此来降低模型的复杂度，常见的添加正则项的正则化技术有L1，L2正则化 

 2、提前终止迭代（Early stopping）：随着迭代次数的增大，部分权值参数会不断的增大。提前终止迭代可以有效的控制权值参数的大小，从而降低模型的复杂度。 

 3、权值共享：权值共享的目是为了减小模型中的参数，同时还能减少计算量。 

 4、数据增强，也就是增加训练数据样本。 

 5、Dropout：在神经网络中，随机地“删除”一部分隐层单元。补充：在前向传播的时候，让某个神经元的激活值以一定的概率停止工作，即输出为0，也不更新参数，这样可以使模型泛化能力更强，因为它不会太依赖某些局部的特征。 

 6、剪枝：剪枝是决策树中一种控制过拟合的方法。预剪枝：通过在训练过程[中控]()制树深、叶子节点数、叶子节点中样本的个数等来控制树的复杂度，就是提前停止训练。后剪枝：是在训练好树模型之后，采用交叉验证的方式进行剪枝以找到最优的树模型。 

 


 **欠拟合**的原因：模型学习不足，没有很好地捕捉到数据特征，不能够很好地拟合数据。或者是因为模型太简单了。 

 解决方法：增加特征，使用组合特征，减少正则化参数。 

###  **4****、Batch Normalization** 

 Normalization：将一组范围差距较大或者量级不同的数据，按照一定的规则变化到指定的范围内 

 BN的原因：随着网络的深度增加，每一层的特征值分布会逐渐向激活函数的饱和区间靠近，这样就会导致梯度消失。BN能够将当前层的特征值分布重新拉回标准正态分布，特征值会集中在激活函数的敏感区间，就算输入的变化较小也可导致损失函数的较大变化，使得梯度变大，避免梯度消失，同时也可加快收敛。（一般是放在激活函数之前吧？） 

 【补充】增加两个调节参数的原因：比如我网络中间某一层学习到特征数据本身就分布在S型激活函数的两侧，你强制把它给我归一化处理，标准差也限制在了1，把数据变换成分布于s函数的中间部分，这样就相当于我这一层网络所学习到的特征分布被你搞坏了 

 为了防止网络表达能力下降，每个神经元增加两个调节参数（scale和shift），这两个参数是通过训练来学习到的，用来对变换后的激活反变换，使得网络表达能力增强。 

###  **5****、反向传播** 

 没有总结 

 


###  **6****、决策树和随机森林** 

 **决策树**是一种树形结构，其中每个内部节点表示一个属性上的判断，每个分支代表一个判断结果的输出，每个叶节点代表一种分类结果。 

 决策树构造：1、节点的熵迅速降低；2、熵降低的速度越快越好；3、得到一颗最矮的决策树。 

 信息增益gain：原始熵-当前熵 

 ID3[算法]()：信息增益最大化；缺点：考虑ID，每个ID出现一次，所以算出的信息增益大，但是没有意义 

 C4.5: 信息增益率：信息增益/当前特征的熵 

 **回归决策树**：是将特征空间划分成若干单元，每一个单元有一个特定的输出。[切分点选择：最小二乘法]；[输出值：单元内均值]. 

 **随机森林** 

 Bootstrapping: 有放回的均匀采样 

 Bagging：有放回的采样得到n个样本，建立n个分类器 

 一次采样构成一颗决策树，多次采样，构成一片森林，多个分类器共同决定结果。当输入一个测试样例时，输入到所有的决策树，共同决策。 

 随机性的解释： 

 \1. 数据选择的随机性：有放回的选择数据集，这样可以有概率的忽略错误数据 

​    \2. 特征的随机选择   

​    


###  **7****、IoU交并比** 

 IOU=(A∩B)/(A∪B) 

 ![img](https://picgo-w.oss-cn-chengdu.aliyuncs.com/img/8069EFFAE450541123991912203C97A2) 

###  **8****、给图像添加噪声** 

 (1) 椒盐噪声  

 椒盐噪声（脉冲噪声）是一种随机出现的白点或者黑点，可能是亮的区域有黑色像素或是在暗的区域有白色像素（或是两者皆有）。  

 图像模拟添加椒盐噪声是通过：随机获取像素点，并设置为高亮度点和低亮度点来实现的。 

 (2) 高斯噪声  

 高斯噪声是指概率密度函数服从高斯分布的一类噪声。高斯噪声的每个像素点都出现噪声。 

​    如果一个噪声，它的幅度分布服从高斯分布，而它的功率谱密度服从均匀分布，则称这个噪声为高斯白噪声。   

​    


###  **9****、图像的特征有哪些** 

 1、颜色特征（颜色直方图） 

 2、形状特征（Sift、hog） 

 3、纹理特征（LBP） 

​    4、边缘特征（   canny、   sobel）   

​    


###  **10****、双线性差值** 

 ![img](https://picgo-w.oss-cn-chengdu.aliyuncs.com/img/4B371B5F9E74C80D451E455EE3D475DB) 

 ![img](https://picgo-w.oss-cn-chengdu.aliyuncs.com/img/ABF6EFF525FABF9B0FF386869037AF69) 

 ![img](https://picgo-w.oss-cn-chengdu.aliyuncs.com/img/C57075642072EA1C2D0264B88EF9364B) 

 首先在 x 方向进行线性插值 

 ![img](https://picgo-w.oss-cn-chengdu.aliyuncs.com/img/FEB650CF664D61AFF2B1BB3A86B0A034) 

 然后在 y 方向进行线性插值 

​    ![img](https://picgo-w.oss-cn-chengdu.aliyuncs.com/img/21B56B8D428610B97DA3333942B77FFD)   

​    


###  **11****、查找第k大数（快排）** 

 **快排**查找第k大数的时间复杂度如下： 

 平均情况下： T(n) = T(n/2) + n; 第一次划分 

 = T(n/4) + n/2 + n;   第二次划分  

 = T(n/8) + n/4 +n/2 +n;   第三次划分 

 =..................... 

 = T(n/n) + 2 + 4 + ... + n; 第m次划分 

 是一个等比数列的求和公式，那么显然T(n) = 2n，平均时间复杂度为O(n) 

 **快速[排序]()**代码：分而治之+递归： 

 ![img](https://picgo-w.oss-cn-chengdu.aliyuncs.com/img/F7D04D5FB96D73F95537D6AB40AE322F) 

###  **12****、[排序]()[算法]()** 

 https://blog.csdn.net/weixin_41190227/article/details/86600821 

 ![img](https://picgo-w.oss-cn-chengdu.aliyuncs.com/img/B399D40AD3CDFBD7DD2DDE190E93A682) 



#  【[前端]()】 

 


###  **●** **居中导航栏** 

 将容器转成「display:inline-block」行内块级元素，然后就可以直接用「text-align:center」使其达到水平居中效果。 

 HTML代码： 

 <div class="navbar"> 

 <ul> 

 <li><a href="/">首页</a></li> 

 … 

 </ul> 

 </div> 

 CSS代码： 

 给外面的div添加「text-align:center」，然后将菜单容器设成「display:inline-block」行内块级元素，菜单浮左「float:left」 

 .navbar { 

 text-align:center; 

 } 

 .navbar ul { 

 display:inline-block; 

 } 

###  **●** **两栏布局实现自适应** 

   **![img](https://picgo-w.oss-cn-chengdu.aliyuncs.com/img/F03E938A84A0E4C6BD0870BF39F1CE3F)
**   

​     

  

  

  

  

  

###  **●** **盒子模型** 

  

 CSS3新增了box-sizing属性来改变盒模型的类型 

 1、content-box为默认值，代表W3C盒模型：盒子定义宽高 = 内容宽高（content） 

   2、  border-box代表  IE盒模型：盒子定义宽高  =内容宽高（  content）  +内边距（  padding）  +边框（  border）  

   ![img](https://picgo-w.oss-cn-chengdu.aliyuncs.com/img/30E4FA96C6DAF4A38095FAD5432D4C04)  




###  **●**  

 弹性盒子是 CSS3 的一种新的布局模式。 

 可以让页面适应不同大小的屏幕和设备类型，确保页面拥有恰当的布局方式。 

 弹性盒子由弹性容器(Flex container)和弹性子元素(Flex item)组成。 

 弹性容器通过设置 display 属性的值为 flex 或 inline-flex定义为弹性容器。 

   弹性容器内包含了一个或多个弹性子元素。  

   




###  **● JS****数据类型** 

 基本数据类型包括undefined、null、number、boolean、string； 

 引用数据类型也就是对象类型Object，比如：Object、array、function、data等； 

 数值（number）：整数和小数（比如1和3.14） 

 字符串（string）：文本（比如Hello World）。 

 布尔值（boolean）：表示真伪的两个特殊值，即true（真）和false（假） 

 undefined：表示“未定义”或不存在，即由于目前没有定义，所以此处暂时没有任何值 

 null：表示空值，即此处的值为空。 

   对象（  object）：各种值组成的集合。  

   




###  **● JS****闭包**  

 闭包是指函数有权访问另一个函数作用域中的变量，参数和变量不会被垃圾回收机制回收 

 闭包优点 

 可以让一个变量保存在内存中，不被垃圾回收机制清除 

 可以避免变量的全局污染 

 可以定义模块，将操作函数暴露到外部，细节隐藏在模块内部 

 闭包缺点 

 容易造成内存泄漏 

   闭包对性能会产生负面影响，包括处理速度和内存消耗  

   




###  **●** **内存泄漏** 

   如果一个变量长期存在内存里，没有被垃圾回收机制清除，就会产生内存泄漏。  

   




###  **●** **变量提升和函数提升** 

 引擎在读取js代码的过程中，分为两步。第一个步骤是整个js代码的解析读取，第二个步骤是执行。 

 在JS代码执行之前，浏览器的解析器在遇到 var 变量名 和function函数时，会将其提升到当前作用域的最前面。 

 1.变量提升只会提升变量名的声明，而不会提升变量的赋值初始化。 

   2.函数提升的优先级大于变量提升的优先级，即函数提升在变量提升之上。  

   




###  **● localStorage****、sessionStorage和Cookie的区别** 

 sessionStorage用于本地存储一个会话中的数据，这些数据只有在同一个会话中的页面才能访问，并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅是会话级别的存储。只允许同一窗口访问。 

 localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。同源可以读取并修改localStorage数据。 

   Cookie非常小，它的大小限制为  4KB左右，它的主要用途有保存登录信息。  

   ![img](https://picgo-w.oss-cn-chengdu.aliyuncs.com/img/A927511B44288FC4A6EC907B532EB43B)  






###  **● js****中的异步操作** 

 JS是单线程的，所以在执行事务的时候，往往会因为某个事务的延迟，而导致服务器假死。 

 1、    回调函数 

 回调是一个函数被作为一个参数传递到另一个函数里，在那个函数执行完后再执行。 

 2、    事件监听 

 当监听事件发生时，先执行回调函数，再对监听事件进行改写 

 3、    观察者模式，也叫订阅发布模式 

 步骤包括：订阅、发布、退订；先订阅(subscribe)一个主题对象，根据主题对象发布(publish)内容，期间也可以退订(unsubscribe)主题对象，一旦退订就无法再次发布。 

 4、    Promise 

 5、    generator（ES6） 

   6、    async/await(ES7)  

   


###  **● Ajax** 

 (1)创建XMLHttpRequest对象,也就是创建一个异步调用对象. 

 (2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息.  

 (3)设置响应HTTP请求状态变化的函数. 

 (4)发送HTTP请求. 

 (5)获取异步调用返回的数据. 

 (6)使用[JavaScript]()和DOM实现局部刷新. 

 **$.ajax**({ 

 type:"get",// get或者post 

 url:"abc.php",// 请求的url地址 

 data:{},//请求的参数 

 dataType:"json",//json写了jq会帮我们转换成数组或者对象，他已经用JSON.parse弄好了  

 timeout:3000,//3秒后提示错误 

 beforeSend:function(){ // 发送之前就会进入这个函数 

 // return false 这个ajax就停止了不会发 如果没有return false 就会继续}, 

 success:function(data){ // 成功拿到结果放到这个函数 data就是拿到的结果}, 

 error:function(){//失败的函数}, 

 complete:function(){//不管成功还是失败 都会进这个函数} 

   })  

   


###  **● promise** 

 是用来处理异步操作的，使用了Promise之后他肯定会给我们答复，无论成功或者失败都会给我们一个答复。 

 Promise有三种状态：pending（进行中），resolved（完成），rejected（失败）。只有异步返回的结构可以改变其状态。所以，promise的过程一般只有两种：pending->resolved或者pending->rejected。 

 Promise实例生成后，可用then方法分别指定两种状态回调参数。 

   在  Promise新建后会立即执行。然后，  then方法指定的回调函数将在当前脚本所有同步任务执行完后才会执行。  

   




###  **● px****、em和rem**  

 px是固定的像素，一旦设置了就无法因为适应页面大小而改变。 

 em和rem是相对长度单位，em相对于父元素，rem相对于根元素。 

   Rem = 目标像素值  /根元素像素值  

   




###  **●** **跨域问题** 

 由于浏览器的同源策略限制，所以会出现跨域的问题。 

 同源策略是浏览器最核心也最基本的安全功能。同源策略会阻止一个域的javascript脚本和另外一个域的内容进行交互。 

   所谓同源是指  "协议  +域名  +端口  "三者相同。  

   ![img](https://picgo-w.oss-cn-chengdu.aliyuncs.com/img/1CA364BEBC3F7F5427BC234EDEB88E8D)  






 **●** **正向代理、反向代理** 

 正向代理：是[客户端]()代理, 代理[客户端](), 服务端不知道实际发起请求的[客户端]()。 

 反向代理：是服务端代理, 代理服务端, [客户端]()不知道实际提供服务的服务端。 

 正向代理的用途： 

 （1）访问原来无法访问的资源，如[google]() 

 （2） 可以做缓存，加速访问资源 

 （3）对[客户端]()访问授权，上网进行认证 

 （4）代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息 

 反向代理的作用： 

 （1）保证内网的安全，阻止web攻击，大型网站，通常将反向代理作为公网访问地址，Web服务器是内网 

   （  2）负载均衡，通过反向代理服务器来优化网站的负载  

   




###  **● Nginx** 

 Nginx由多个模块组成，每个请求都是由一个或多个模块共同完成的。 

   Nginx 里有一个   master 进程和多个   worker 进程。  master 进程并不处理网络请求，主要负责调度工作进程：加载配置、启动工作等。  worker 进程负责处理网络请求与响应。  

   


 master进程主要用来管理worker进程，具体包括如下4个主要功能： 

 1、接收来自外界的信号。 

 2、向各worker进程发送信号。 

 3、监控woker进程的运行状态。 

 4、当woker进程退出后（异常情况下），会自动重新启动新的woker进程。 

 


 woker进程主要用来处理基本的网络事件： 

 1、多个worker进程之间是对等且相互独立的，他们同等竞争来自[客户端]()的请求。 

 2、一个请求，只可能在一个worker进程中处理，一个worker进程，不可能处理其它进程的请求。 

 3、worker进程的个数是可以设置的，一般我们会设置与机器cpu核数一致。同时，nginx为了更好的利用多核特性，具有cpu绑定选项，我们可以将某一个进程绑定在某一个核上，这样就不会因为进程的切换带来cache的失效。 

 


 Nginx的模块从功能上分为如下三类： 

 Handlers（处理器模块）。此类模块直接处理请求，并进行输出内容和修改headers信息等操作。Handlers处理器模块一般只能有一个。 

 Filters （过滤器模块）。此类模块主要对其他处理器模块输出的内容进行修改操作，最后由Nginx输出。 

 Proxies （代理类模块）。此类模块是Nginx的HTTP Upstream之类的模块，这些模块主要与后端一些服务比如FastCGI等进行交互，实现服务代理和负载均衡等功能。 

 


###  **● vue****生命周期** 

 创建、数据初始化、挂载、更新、销毁 

 


 1、创建前（beforeCreate） 

 此阶段为实例初始化之后，此时的数据观察和事件机制都未形成，不能获得DOM节点。 

 2、创建后（created） 

 在这个阶段vue实例已经创建，但仍然不能获取DOM元素。 

 3、载入前（beforeMount） 

 在这一阶段，我们虽然依然得不到具体的DOM元素，但vue挂载的根节点已经创建，下面vue对DOM的操作将围绕这个根元素继续进行；beforeMount这个阶段是过渡性的，一般一个[项目]()只能用到一两次。 

 4、载入后（mounted） 

 mounted是平时我们使用最多的函数了，一般我们的异步请求都写在这里。在这个阶段，数据和DOM都已被渲染出来。 

 5、更新前（beforeUpdate） 

 在这一阶段，vue遵循数据驱动DOM的原则；beforeUpdate函数在数据更新后虽然没立即更新数据，但是DOM中的数据会改变，这是Vue双向数据绑定的作用。 

 6、更新后（updated） 

 在这一阶段DOM会和更改过的内容同步。 

 7、销毁前（beforeDestroy） 

 在上一阶段vue已经成功的通过数据驱动DOM更新，当我们不在需要vue操纵DOM时，就需要销毁Vue，也就是清除vue实例与DOM的关联，调用destroy方法可以销毁当前组件。在销毁前，会触发beforeDestroy钩子函数。 

 8、销毁后（destroyed） 

   在销毁后，会触发  destroyed钩子函数。  

   ![img](https://picgo-w.oss-cn-chengdu.aliyuncs.com/img/D2D751D5262FFEB57479E750E9024473)  



  

  

###  **● ES6****新特性** 

 1、const 与 let 变量 

 Var会有变量提升特性，const和let只在块级作用域内作用, 不存在变量提升。 

 let表示声明变量，而const表示声明常量，必须初始化 

 2、模板表达式 

 用倒引号 ( `` )表示，可以包含用 ${expression} 表示的占位符 

 3、箭头函数 

   用括号包裹参数，跟随一个   =>，紧接着是函数体。  

   ![img](https://picgo-w.oss-cn-chengdu.aliyuncs.com/img/8B1CC14C3E0F3DB29C0D2B000A43350A)  






 4、Promise 

 5、解构 

 对数组或者对象进行模式匹配，然后对其中的变量进行赋值。 

 6、for…of… 

 for 循环的最大缺点是需要跟踪计数器和退出条件。 

 for...in消除了跟踪技术器和退出条件，但是依然需要使用 index 来访问数组的值。 

   for...of遍历对象，可以获取对应的元素，而  for...in遍历对象，是获取对应元素的索引；同样的，  for...of是遍历获取对象中的  value，而  for...in是获取对象的  key。  

   




###  **● js****的原型和原型链** 

 每个函数都有一个 prototype 属性 

 每一个[JavaScript]()对象(null除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型"继承"属性。 

   原型链就是依赖对象的  _proto_的指向，当出现自身不存在的属性时，就一层层的扒出创建对象的构造函数，直至到  Object时，就没有  _proto_指向了。  

   ![img](https://picgo-w.oss-cn-chengdu.aliyuncs.com/img/B7C701ED49DBA3BC76E3F94AFAA55008)  



  

  

  

###  **● html5****新特性** 

 1、语义标签：可以使开发者更方便清晰构建页面的布局 

 2、增强型表单：新的input type，新的表单元素，表单元素的新属性 

 3、视频和音频：html5提供了音频和视频文件的标准 

 音频：<audio src=" "></audio> 

 视频：<video src=" "></video> 

 4、Canvas绘图 

 5、SVG绘图 

 SVG适用于描述XML中的2D图形的语言 

 Canvas使用javaScript绘制2D图形 

 Canvas是位图；SVG是矢量图 

 Canvas内容不能使用CSS；SVG内容可以使用CSS； 

 6、地理定位：通过浏览器获取当前用户所在的地理坐标 

 情形1：用户使用手机浏览器——可以根据内置GPS芯片读取数据 

 情形2：用户使用PC浏览器——可以根据电脑的IP地址进行反向查询(需要很大的IP分配库) 

 7、拖放API 

 拖放是一种常见的特性，即抓取对象以后拖到另一个位置。 

 拖放的过程分为源对象和目标对象。源对象是指你即将拖动元素，而目标对象则是指拖动之后要放置的目标位置。 

 8、web worker：是运行在后台的 [JavaScript]()，通过加载一个脚本文件，进而创建一个独立工作的线程，在主线程之外运行，起到互不阻塞执行的效果。 

 9、Web Storage：解决本来不应该cookie做，却不得不用cookie的本地存储。 

 localStorage：没有时间限制的数据存储。 

 sessionStorage:在浏览器关闭的时候就会清除。 

 10、WebSocket：为web应用程序[客户端]()和服务端之间提供了一种全双工通信机制。 

 浏览器通过 [JavaScript]() 向服务器发出建立 WebSocket 连接的请求，连接建立以后，[客户端]()和服务器端就可以通过 TCP 连接直接交换数据。 

   当获取   Web Socket 连接后，可以通过   send() 方法来向服务器发送数据，并通过   onmessage 事件来接收服务器返回的数据。  

   




###  **● http****缓存** 

 当[客户端]()向服务器请求资源时，会先抵达浏览器缓存，如果浏览器有“要请求资源”的副本，就可以直接从浏览器缓存中提取而不是从原始服务器中提取这个资源。 

 第一次请求资源时，服务器返回资源，并在respone header头中回传资源的缓存参数； 

   第二次请求时，浏览器判断这些请求参数，命中强缓存就直接  200，否则就把请求参数加到  request header头中传给服务器，看是否命中协商缓存，命中则返回  304，否则服务器会返回新的资源。  

   ![img](https://picgo-w.oss-cn-chengdu.aliyuncs.com/img/8AF97FB17F04105EB5CCC53DE8F0F487)  

   ![img](https://picgo-w.oss-cn-chengdu.aliyuncs.com/img/0E7DCE085675443A4B857295D3CF8001)  

   ![img](https://picgo-w.oss-cn-chengdu.aliyuncs.com/img/D7238462BFAA51DC1D689171F8A9FB62)  

   










###  **● get** **和 post** 

 GET把参数包含在URL中，POST通过request body传递参数。 

 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）； 

   对于  POST，浏览器先发送  header，服务器响应  100 continue，浏览器再发送  data，服务器响应  200 ok（返回数据）。  

   




###  **●** **[前端]()安全问题** 

 1、XSS（Cross Site Scripting）跨站脚本攻击 

   2、  CSRF跨站伪造请求  

   




###  **● XSS** 

 XSS是一种代码注入攻击。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全。 

 **以下内容都不可信：** 

 来自用户的 UGC 信息 

 来自第三方的链接 

 URL 参数 

 POST 参数 

 Referer （可能来自不可信的来源） 

   Cookie （可能来自其他子域注入）  

   ![img](https://picgo-w.oss-cn-chengdu.aliyuncs.com/img/7678CE020FE10614D27EEA8E21475E1A)  






 **存储型 XSS** 的攻击步骤： 

 1、攻击者将恶意代码提交到目标网站的数据库中。 

 2、用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。 

 3、用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。 

 4、恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。 

 **反射型 XSS** 的攻击步骤： 

 1、攻击者构造出特殊的 URL，其中包含恶意代码。 

 2、用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。 

 3、用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。 

 4、恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。 

 **DOM** **型 XSS** 的攻击步骤： 

 1、攻击者构造出特殊的 URL，其中包含恶意代码。 

 2、用户打开带有恶意代码的 URL。 

 3、用户浏览器接收到响应后解析执行，[前端]() [JavaScript]() 取出 URL 中的恶意代码并执行。 

 4、恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。 

 


 **DOM** **型 XSS 跟前两种 XSS 的区别：**DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于[前端]() [JavaScript]() 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。 

 


 **预防攻击** 

 1、改成纯[前端]()渲染，把代码和数据分隔开 

 纯[前端]()渲染的过程： 

 1）、浏览器先加载一个静态 HTML，此 HTML 中不包含任何跟业务相关的数据。 

 2）、然后浏览器执行 HTML 中的 [JavaScript]()。 

 3）、[JavaScript]() 通过 Ajax 加载业务数据，调用 DOM API 更新到页面上。 

 2、转义 HTML 

 采用合适的转义库，对 HTML 模板各处插入点进行充分的转义。 

   3、  CSP（  Content Security Policy）内容安全策略：用于指定哪些内容可执行  

   




###  **● CSRF****跨站请求伪造** 

   攻击者盗用了你的身份，以你的名义发送恶意请求。  

   ![img](https://picgo-w.oss-cn-chengdu.aliyuncs.com/img/070C75AF8937F2966AE97ED407556233)  






 **防范：** 

 1、检测请求头中的Referer字段 

 Referer字段通常与Host字段的域名是一样的，可以检测Referer字段值，如果发现其与Host值不在同一域名下，这时候服务器就能够识别出恶意的访问了。 

 2、添加检验token 

 在访问敏感数据请求时，要求用户浏览器提供不保存在 cookie中，并且攻击者无法伪造的数据作为校验，那么攻击者就无法再执行 CSRF攻击。  

 


#  【测试】 

###  **●** **测试用例** 

 测试用例是为某个特殊目标而编制的一组测试输入、执行条件以及预期结果，用于核实是否满足某个特定软件需求。 

 


###  **●** **性能测试** 

 **定义**：模拟多种正常、峰值以及异常负载条件来对系统的各项性能指标进行测试。 

 1、基准测试：在给系统施加较低压力时，查看系统的运行状况并记录相关数做为基础参考 

 2、负载测试：是指对系统不断地增加压力或增加一定压力持续一段时间，直到系统的某项或多项性能指标达到安全临界值，例如某种资源已经达到饱和状态等 。 

 3、压力测试：压力测试是评估系统处于或超过预期负载时系统的运行情况，关注点在于系统在峰值负载或超出最大载荷情况下的处理能力。 

 4、稳定性测试：在给系统加载一定业务压力的情况下，使系统运行一段时间，以此检测系统是否稳定。 

 5、并发测试：测试多个用户同时访问同一个应用、同一个模块或者数据记录时是否存在死锁或者其他性能问题 

​    **性能指标**：响应时间、吞吐量、服务器资源占用   

​    




###  **●** **安全测试** 

 (1) 用户认证机制：如明确区分系统中不同用户权限；用户登陆密码是否是可见、可复制；是否可以通过绝对途径登陆系统；是否可以使用后退键而不通过输入口令进入系统 

 (2) 加密机制 

 (3) 安全防护策略：如安全日志、入侵检测、隔离防护、漏洞扫描 

 (4) 数据备份与恢复手段：存储设备、存储优化、存储保护、存储管理 

​    (5) 防病毒系统   

​    




###  **●** **等价类划分（一种黑盒测试法）** 

 将所有可能输入数据的数据域进行划分，分成若干子集，再从其中选出少数具有代表性的的是用例测试程序。 

​    等价类划分可有两种不同的情况：有效等价类和无效等价类。   

​    




###  **●****软件开发流程** 

 1、需求分析 

 2、概要设计 

 3、详细设计 

 4、编码 

 5、测试 

 6、软件交付 

 7、验收 

​    8、维护   

​    




###  **●****测试的基本流程** 

​    **![img](https://picgo-w.oss-cn-chengdu.aliyuncs.com/img/1E1AE808D6A5815BF55FF6F9B8FD2D25)
**    

​    **
**    

 


###  **●****测试方法** 

 白盒测试方法：代码检査法、静态结构分析法、静态质量度量法、逻辑覆盖法、基本路径测试法、域测试、符号测试、路径覆盖和程序变异。 

​    黑盒测试方法：等价类划分法、边界值分析法、错误推测法、因果图法、判定表驱动法、正交试验设计法、功能图法、场景法等。   

​    




###  **●****如何测试一个水杯** 

 1、功能测试(Function test) 

 能否装水， 

 除了装水， 能否装其他液体。比如可乐，酒精 

 能装多少ML的水 

 杯子是否有刻度表 

 杯子能否泡茶，跑咖啡 

 杯子是否能放冰箱，做冰块 

 杯子的材质是什么（玻璃，塑料,黄金做的） 

 2、界面测试(UI Test) 

 外观好不好看。 

 什么颜色 

 杯子的形状是怎么样的。 

 杯子的重量是多少 

 杯子是否有异味 

 杯子的图案是否合理 

 3、性能测试(performance test) 

 能否装100度的开水 (泡茶) 

 能否装0度冰水 

 装满水，放几天后，是否会漏水 

 杯子内壁上的涂料是否容易脱落。 

 杯子上的颜色是否容易褪色或者脱落 

 被我压下，是否会碎 (这条是开玩笑的哈) 

 4、安全性测试(Security test) 

 制作杯子的材料，是否有毒 

 放微波炉里转的时候，是否会爆炸, 或者杯子是否会熔化。 

 从桌子上掉到水泥地上是否会摔碎。 

 杯子是否容易长细菌 

 杯子是否有缺口，会划坏嘴巴 

 杯子内壁上的材料，是否会溶解到水中 

 杯子破碎后，是否会对使用者造成伤害 

 5、可用性测试(Usability Test) 

 杯子是否容易烫手 

 杯子是否好端，好拿 

 杯子的水是否容易喝到 

​    杯子是否有防滑措施   

​    




###  **●****如何测试一个电梯** 

 1、功能：上升、下降、停止、开门、关门、梯内电话、灯光、指示灯等； 

 2、性能：速度、反应时间、关门时间等； 

 3、压力：超载、尖锐物碰撞电梯壁等； 

 4、安全：停电、报警装置、轿箱停靠位置、有人扒门时的情况等； 

 5、可用性：按键高度、操作是否方便、舒适程度等； 

 6、UI：美观程度、光滑程度、形状、质感等； 

 7、稳定性：长时间运行情况等； 

 8、兼容性：不同电压是否可工作、不同类型电话是否可安装等